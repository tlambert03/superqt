{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"superqt \"missing\" widgets and components for PyQt/PySide This repository aims to provide high-quality community-contributed Qt widgets and components for PyQt & PySide that are not provided in the native QtWidgets module. Components are tested on: macOS, Windows, & Linux Python 3.7 and above PyQt5 (5.11 and above) & PyQt6 PySide2 (5.11 and above) & PySide6 Installation pip install superqt conda install -c conda-forge superqt Usage See the Widgets and Utilities pages for features offered by superqt.","title":"superqt"},{"location":"#superqt","text":"","title":"superqt"},{"location":"#missing-widgets-and-components-for-pyqtpyside","text":"This repository aims to provide high-quality community-contributed Qt widgets and components for PyQt & PySide that are not provided in the native QtWidgets module. Components are tested on: macOS, Windows, & Linux Python 3.7 and above PyQt5 (5.11 and above) & PyQt6 PySide2 (5.11 and above) & PySide6","title":"\"missing\" widgets and components for PyQt/PySide"},{"location":"#installation","text":"pip install superqt conda install -c conda-forge superqt","title":"Installation"},{"location":"#usage","text":"See the Widgets and Utilities pages for features offered by superqt.","title":"Usage"},{"location":"faq/","text":"FAQ Sliders not dragging properly on MacOS 12+ Details On MacOS Monterey, with Qt5, there is a bug that causes all sliders (including native Qt sliders) to not respond properly to drag events. See: https://bugreports.qt.io/browse/QTBUG-98093 https://github.com/pyapp-kit/superqt/issues/74 Superqt includes a workaround for this issue, but it is not perfect, and it requires using a custom stylesheet (which may interfere with your own styles). Note that you may not see this issue if you're already using custom stylesheets. To opt in to the workaround, do any of the following: set the environment variable USE_MAC_SLIDER_PATCH=1 before importing superqt (note: this is safe to use even if you're targeting more than just MacOS 12, it will only be applied when needed) call the applyMacStylePatch() method on any of the superqt slider subclasses (note, this will override your slider styles) apply the stylesheet manually: from superqt.sliders import MONTEREY_SLIDER_STYLES_FIX slider . setStyleSheet ( MONTEREY_SLIDER_STYLES_FIX )","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#sliders-not-dragging-properly-on-macos-12","text":"Details On MacOS Monterey, with Qt5, there is a bug that causes all sliders (including native Qt sliders) to not respond properly to drag events. See: https://bugreports.qt.io/browse/QTBUG-98093 https://github.com/pyapp-kit/superqt/issues/74 Superqt includes a workaround for this issue, but it is not perfect, and it requires using a custom stylesheet (which may interfere with your own styles). Note that you may not see this issue if you're already using custom stylesheets. To opt in to the workaround, do any of the following: set the environment variable USE_MAC_SLIDER_PATCH=1 before importing superqt (note: this is safe to use even if you're targeting more than just MacOS 12, it will only be applied when needed) call the applyMacStylePatch() method on any of the superqt slider subclasses (note, this will override your slider styles) apply the stylesheet manually: from superqt.sliders import MONTEREY_SLIDER_STYLES_FIX slider . setStyleSheet ( MONTEREY_SLIDER_STYLES_FIX )","title":"Sliders not dragging properly on MacOS 12+"},{"location":"utilities/","text":"Utilities Font Icons Object Description addFont Add an OTF/TTF file at to the font registry. font Create QFont for a given font-icon font family key icon Create a QIcon for font-con glyph key setTextIcon Set text on a QWidget to a specific font & glyph. IconFont Helper class that provides a standard way to create an IconFont . IconOpts Options for rendering an icon Animation Base class for adding animations to a font-icon. Threading tools Object Description ensure_main_thread Decorator that ensures a function is called in the main QApplication thread. ensure_object_thread Decorator that ensures a QObject method is called in the object's thread. FunctionWorker QRunnable with signals that wraps a simple long-running function. GeneratorWorker QRunnable with signals that wraps a long-running generator. create_worker Create a worker to run a target function in another thread. thread_worker Decorator for create_worker , turn a function into a worker. Miscellaneous Object Description QMessageHandler A context manager to intercept messages from Qt. CodeSyntaxHighlight A QSyntaxHighlighter for code syntax highlighting.","title":"Utilities"},{"location":"utilities/#utilities","text":"","title":"Utilities"},{"location":"utilities/#font-icons","text":"Object Description addFont Add an OTF/TTF file at to the font registry. font Create QFont for a given font-icon font family key icon Create a QIcon for font-con glyph key setTextIcon Set text on a QWidget to a specific font & glyph. IconFont Helper class that provides a standard way to create an IconFont . IconOpts Options for rendering an icon Animation Base class for adding animations to a font-icon.","title":"Font Icons"},{"location":"utilities/#threading-tools","text":"Object Description ensure_main_thread Decorator that ensures a function is called in the main QApplication thread. ensure_object_thread Decorator that ensures a QObject method is called in the object's thread. FunctionWorker QRunnable with signals that wraps a simple long-running function. GeneratorWorker QRunnable with signals that wraps a long-running generator. create_worker Create a worker to run a target function in another thread. thread_worker Decorator for create_worker , turn a function into a worker.","title":"Threading tools"},{"location":"utilities/#miscellaneous","text":"Object Description QMessageHandler A context manager to intercept messages from Qt. CodeSyntaxHighlight A QSyntaxHighlighter for code syntax highlighting.","title":"Miscellaneous"},{"location":"utilities/code_syntax_highlight/","text":"CodeSyntaxHighlight A code highlighter subclass of QSyntaxHighlighter that can be used to highlight code in a QTextEdit. Code lexer and available styles are from pygments python library List of available languages are available here . List of available styles are available here . Example from qtpy.QtGui import QColor , QPalette from qtpy.QtWidgets import QApplication , QTextEdit from superqt.utils import CodeSyntaxHighlight app = QApplication ([]) text_area = QTextEdit () highlight = CodeSyntaxHighlight ( text_area . document (), \"python\" , \"monokai\" ) palette = text_area . palette () palette . setColor ( QPalette . Base , QColor ( highlight . background_color )) text_area . setPalette ( palette ) text_area . setText ( \"\"\"from argparse import ArgumentParser def main(): parser = ArgumentParser() parser.add_argument(\"name\", help=\"Your name\") args = parser.parse_args() print(f\"Hello {args.name}\") if __name__ == \"__main__\": main() \"\"\" ) text_area . show () text_area . resize ( 400 , 200 ) app . exec_ () Qt Class QSyntaxHighlighter Methods background_color () property","title":"CodeSyntaxHighlight"},{"location":"utilities/code_syntax_highlight/#codesyntaxhighlight","text":"A code highlighter subclass of QSyntaxHighlighter that can be used to highlight code in a QTextEdit. Code lexer and available styles are from pygments python library List of available languages are available here . List of available styles are available here .","title":"CodeSyntaxHighlight"},{"location":"utilities/code_syntax_highlight/#example","text":"from qtpy.QtGui import QColor , QPalette from qtpy.QtWidgets import QApplication , QTextEdit from superqt.utils import CodeSyntaxHighlight app = QApplication ([]) text_area = QTextEdit () highlight = CodeSyntaxHighlight ( text_area . document (), \"python\" , \"monokai\" ) palette = text_area . palette () palette . setColor ( QPalette . Base , QColor ( highlight . background_color )) text_area . setPalette ( palette ) text_area . setText ( \"\"\"from argparse import ArgumentParser def main(): parser = ArgumentParser() parser.add_argument(\"name\", help=\"Your name\") args = parser.parse_args() print(f\"Hello {args.name}\") if __name__ == \"__main__\": main() \"\"\" ) text_area . show () text_area . resize ( 400 , 200 ) app . exec_ ()","title":"Example"},{"location":"utilities/code_syntax_highlight/#qt-class","text":"QSyntaxHighlighter","title":"Qt Class"},{"location":"utilities/code_syntax_highlight/#methods","text":"","title":"Methods"},{"location":"utilities/code_syntax_highlight/#superqt.utils._code_syntax_highlight.CodeSyntaxHighlight.background_color","text":"","title":"background_color()"},{"location":"utilities/fonticon/","text":"Font icons The superqt.fonticon module provides a set of utilities for working with font icons such as Font Awesome or Material Design Icons . Basic Example from fonticon_fa5 import FA5S from qtpy.QtCore import QSize from qtpy.QtWidgets import QApplication , QPushButton from superqt.fonticon import icon , pulse app = QApplication ([]) btn2 = QPushButton () btn2 . setIcon ( icon ( FA5S . smile , color = \"blue\" )) btn2 . setIconSize ( QSize ( 225 , 225 )) btn2 . show () app . exec () Font Icon plugins Ready-made fonticon packs are available as plugins: Font Awesome 5 pip install fonticon-fontawesome5 Font Awesome 6 pip install fonticon-fontawesome6 Material Design Icons pip install fonticon-materialdesignicons6 See also https://github.com/tlambert03/fonticon-bootstrapicons https://github.com/tlambert03/fonticon-linearicons https://github.com/tlambert03/fonticon-feather superqt.fonticon is a pluggable system, and font icon packs may use the \"superqt.fonticon\" entry point to register themselves with superqt. See fonticon-cookiecutter for a template, or look through the following repos for examples: https://github.com/tlambert03/fonticon-fontawesome6 https://github.com/tlambert03/fonticon-fontawesome5 https://github.com/tlambert03/fonticon-materialdesignicons6 API superqt . fonticon . icon ( glyph_key , scale_factor = DEFAULT_SCALING_FACTOR , color = None , opacity = 1 , animation = None , transform = None , states = None ) Create a QIcon for glyph_key , with a number of optional settings The glyph_key (e.g. 'fa5s.smile') represents a Font-family & style, and a glpyh. In most cases, the key should be provided by a plugin in the environment, like: fonticon-fontawesome5 ('fa5s' & 'fa5r' prefixes) fonticon-materialdesignicons6 ('mdi6' prefix) ...but fonts can also be added manually using addFont . Parameters: Name Type Description Default glyph_key str String encapsulating a font-family, style, and glyph. e.g. 'fa5s.smile'. required scale_factor float , optional Scale factor (fraction of widget height), When widget icon is painted on widget, it will use font.setPixelSize(round(wdg.height() * scale_factor)) . by default 0.875. DEFAULT_SCALING_FACTOR color ValidColor , optional Color for the font, by default None. (e.g. The default QColor ) Valid color types include QColor , int , str , Qt.GlobalColor , tuple (of integer: RGB[A]) (anything that can be passed to QColor ). None opacity float , optional Opacity of icon, by default 1 1 animation Animation , optional Animation for the icon. A subclass of superqt.fonticon.Animation, that provides a concrete animate method. (see \"spin\" and \"pulse\" for examples). by default None. None transform QTransform , optional A QTransform to apply when painting the icon, by default None None states dict , optional Provide additional styling for the icon in different states. states must be a mapping of string to dict, where: the key represents a QIcon.State (\"on\", \"off\"), a QIcon.Mode (\"normal\", \"active\", \"selected\", \"disabled\"), or any combination of a state & mode separated by an underscore (e.g. \"off_active\", \"selected_on\", etc...). the value is a dict with all of the same key/value meanings listed above as parameters to this function (e.g. glyph_key , color , scale_factor , animation , etc...) Missing keys in the state dicts will be taken from the default options, provided by the paramters above. None Returns: Type Description QFontIcon A subclass of QIcon. Can be used wherever QIcons are used, such as widget.setIcon() Examples: simple example (using the string 'fa5s.smile' assumes the fonticon-fontawesome5 plugin is installed) >>> btn = QPushButton () >>> btn . setIcon ( icon ( 'fa5s.smile' )) can also directly import from fonticon_fa5 >>> from fonticon_fa5 import FA5S >>> btn . setIcon ( icon ( FA5S . smile )) with animation >>> btn2 = QPushButton () >>> btn2 . setIcon ( icon ( FA5S . spinner , animation = pulse ( btn2 ))) complicated example >>> btn = QPushButton () >>> btn . setIcon ( ... icon ( ... FA5S . ambulance , ... color = \"blue\" , ... states = { ... \"active\" : { ... \"glyph\" : FA5S . bath , ... \"color\" : \"red\" , ... \"scale_factor\" : 0.5 , ... \"animation\" : pulse ( btn ), ... }, ... \"disabled\" : { ... \"color\" : \"green\" , ... \"scale_factor\" : 0.8 , ... \"animation\" : spin ( btn ) ... }, ... }, ... ) ... ) >>> btn . setIconSize ( QSize ( 256 , 256 )) >>> btn . show () superqt . fonticon . setTextIcon ( widget , glyph_key , size = None ) Set text on a widget to a specific font & glyph. This is an alternative to setting a QIcon with a pixmap. It may be easier to combine with dynamic stylesheets. Parameters: Name Type Description Default widget QWidget A widget supporting a setText method. required glyph_key str String encapsulating a font-family, style, and glyph. e.g. 'fa5s.smile'. required size int , optional Size for QFont. passed to setPixelSize , by default None None superqt . fonticon . font ( font_prefix , size = None ) Create QFont for font_prefix Parameters: Name Type Description Default font_prefix str Font_prefix, such as 'fa5s' or 'mdi6', representing a font-family and style. required size int , optional Size for QFont. passed to setPixelSize , by default None None Returns: Type Description QFont QFont instance that can be used to add fonticons to widgets. superqt.fonticon.IconOpts dataclass Options for rendering an icon. Parameters: Name Type Description Default glyph_key str , optional The key of the glyph to use, e.g. 'fa5s.smile' , by default None _Unset scale_factor float , optional The scale factor to use, by default None _Unset color ValidColor , optional The color to use, by default None . Colors may be specified as a string, QColor , Qt.GlobalColor , or a 3 or 4-tuple of integers. _Unset opacity float , optional The opacity to use, by default None _Unset animation Animation , optional The animation to use, by default None _Unset superqt . fonticon . addFont ( filepath , prefix , charmap = None ) Add OTF/TTF file at filepath to the registry under prefix . If you'd like to later use a fontkey in the form of prefix.some-name , then charmap must be provided and provide a mapping for all of the glyph names to their unicode numbers. If a charmap is not provided, glyphs must be directly accessed with their unicode as something like key.\uffff . Note in most cases, users will not need this. Instead, they should install a font plugin, like: fonticon-fontawesome5 fonticon-materialdesignicons6 Parameters: Name Type Description Default filepath str Path to an OTF or TTF file containing the fonts required prefix str A prefix that will represent this font file when used for lookup. For example, 'fa5s' for 'Font-Awesome 5 Solid'. required charmap Dict [ str , str ], optional optional mapping for all of the glyph names to their unicode numbers. See note above. None Returns: Type Description Tuple [ str , str ], optional font-family and font-style for the file just registered, or None if something goes wrong. Animations the animation parameter to icon() accepts a subclass of Animation that will be superqt.fonticon.Animation Bases: ABC Base icon animation class. animate ( painter ) abstractmethod Setup and start the timer for the animation. superqt.fonticon.pulse Bases: spin Animation that spins an icon in slower, discrete steps. superqt.fonticon.spin Bases: Animation Animation that smoothly spins an icon.","title":"Font icons"},{"location":"utilities/fonticon/#font-icons","text":"The superqt.fonticon module provides a set of utilities for working with font icons such as Font Awesome or Material Design Icons .","title":"Font icons"},{"location":"utilities/fonticon/#basic-example","text":"from fonticon_fa5 import FA5S from qtpy.QtCore import QSize from qtpy.QtWidgets import QApplication , QPushButton from superqt.fonticon import icon , pulse app = QApplication ([]) btn2 = QPushButton () btn2 . setIcon ( icon ( FA5S . smile , color = \"blue\" )) btn2 . setIconSize ( QSize ( 225 , 225 )) btn2 . show () app . exec ()","title":"Basic Example"},{"location":"utilities/fonticon/#font-icon-plugins","text":"Ready-made fonticon packs are available as plugins:","title":"Font Icon plugins"},{"location":"utilities/fonticon/#font-awesome-5","text":"pip install fonticon-fontawesome5","title":"Font Awesome 5"},{"location":"utilities/fonticon/#font-awesome-6","text":"pip install fonticon-fontawesome6","title":"Font Awesome 6"},{"location":"utilities/fonticon/#material-design-icons","text":"pip install fonticon-materialdesignicons6","title":"Material Design Icons"},{"location":"utilities/fonticon/#see-also","text":"https://github.com/tlambert03/fonticon-bootstrapicons https://github.com/tlambert03/fonticon-linearicons https://github.com/tlambert03/fonticon-feather superqt.fonticon is a pluggable system, and font icon packs may use the \"superqt.fonticon\" entry point to register themselves with superqt. See fonticon-cookiecutter for a template, or look through the following repos for examples: https://github.com/tlambert03/fonticon-fontawesome6 https://github.com/tlambert03/fonticon-fontawesome5 https://github.com/tlambert03/fonticon-materialdesignicons6","title":"See also"},{"location":"utilities/fonticon/#api","text":"","title":"API"},{"location":"utilities/fonticon/#superqt.fonticon.icon","text":"Create a QIcon for glyph_key , with a number of optional settings The glyph_key (e.g. 'fa5s.smile') represents a Font-family & style, and a glpyh. In most cases, the key should be provided by a plugin in the environment, like: fonticon-fontawesome5 ('fa5s' & 'fa5r' prefixes) fonticon-materialdesignicons6 ('mdi6' prefix) ...but fonts can also be added manually using addFont . Parameters: Name Type Description Default glyph_key str String encapsulating a font-family, style, and glyph. e.g. 'fa5s.smile'. required scale_factor float , optional Scale factor (fraction of widget height), When widget icon is painted on widget, it will use font.setPixelSize(round(wdg.height() * scale_factor)) . by default 0.875. DEFAULT_SCALING_FACTOR color ValidColor , optional Color for the font, by default None. (e.g. The default QColor ) Valid color types include QColor , int , str , Qt.GlobalColor , tuple (of integer: RGB[A]) (anything that can be passed to QColor ). None opacity float , optional Opacity of icon, by default 1 1 animation Animation , optional Animation for the icon. A subclass of superqt.fonticon.Animation, that provides a concrete animate method. (see \"spin\" and \"pulse\" for examples). by default None. None transform QTransform , optional A QTransform to apply when painting the icon, by default None None states dict , optional Provide additional styling for the icon in different states. states must be a mapping of string to dict, where: the key represents a QIcon.State (\"on\", \"off\"), a QIcon.Mode (\"normal\", \"active\", \"selected\", \"disabled\"), or any combination of a state & mode separated by an underscore (e.g. \"off_active\", \"selected_on\", etc...). the value is a dict with all of the same key/value meanings listed above as parameters to this function (e.g. glyph_key , color , scale_factor , animation , etc...) Missing keys in the state dicts will be taken from the default options, provided by the paramters above. None Returns: Type Description QFontIcon A subclass of QIcon. Can be used wherever QIcons are used, such as widget.setIcon() Examples: simple example (using the string 'fa5s.smile' assumes the fonticon-fontawesome5 plugin is installed) >>> btn = QPushButton () >>> btn . setIcon ( icon ( 'fa5s.smile' )) can also directly import from fonticon_fa5 >>> from fonticon_fa5 import FA5S >>> btn . setIcon ( icon ( FA5S . smile )) with animation >>> btn2 = QPushButton () >>> btn2 . setIcon ( icon ( FA5S . spinner , animation = pulse ( btn2 ))) complicated example >>> btn = QPushButton () >>> btn . setIcon ( ... icon ( ... FA5S . ambulance , ... color = \"blue\" , ... states = { ... \"active\" : { ... \"glyph\" : FA5S . bath , ... \"color\" : \"red\" , ... \"scale_factor\" : 0.5 , ... \"animation\" : pulse ( btn ), ... }, ... \"disabled\" : { ... \"color\" : \"green\" , ... \"scale_factor\" : 0.8 , ... \"animation\" : spin ( btn ) ... }, ... }, ... ) ... ) >>> btn . setIconSize ( QSize ( 256 , 256 )) >>> btn . show ()","title":"icon()"},{"location":"utilities/fonticon/#superqt.fonticon.setTextIcon","text":"Set text on a widget to a specific font & glyph. This is an alternative to setting a QIcon with a pixmap. It may be easier to combine with dynamic stylesheets. Parameters: Name Type Description Default widget QWidget A widget supporting a setText method. required glyph_key str String encapsulating a font-family, style, and glyph. e.g. 'fa5s.smile'. required size int , optional Size for QFont. passed to setPixelSize , by default None None","title":"setTextIcon()"},{"location":"utilities/fonticon/#superqt.fonticon.font","text":"Create QFont for font_prefix Parameters: Name Type Description Default font_prefix str Font_prefix, such as 'fa5s' or 'mdi6', representing a font-family and style. required size int , optional Size for QFont. passed to setPixelSize , by default None None Returns: Type Description QFont QFont instance that can be used to add fonticons to widgets.","title":"font()"},{"location":"utilities/fonticon/#superqt.fonticon.IconOpts","text":"Options for rendering an icon. Parameters: Name Type Description Default glyph_key str , optional The key of the glyph to use, e.g. 'fa5s.smile' , by default None _Unset scale_factor float , optional The scale factor to use, by default None _Unset color ValidColor , optional The color to use, by default None . Colors may be specified as a string, QColor , Qt.GlobalColor , or a 3 or 4-tuple of integers. _Unset opacity float , optional The opacity to use, by default None _Unset animation Animation , optional The animation to use, by default None _Unset","title":"IconOpts"},{"location":"utilities/fonticon/#superqt.fonticon.addFont","text":"Add OTF/TTF file at filepath to the registry under prefix . If you'd like to later use a fontkey in the form of prefix.some-name , then charmap must be provided and provide a mapping for all of the glyph names to their unicode numbers. If a charmap is not provided, glyphs must be directly accessed with their unicode as something like key.\uffff . Note in most cases, users will not need this. Instead, they should install a font plugin, like: fonticon-fontawesome5 fonticon-materialdesignicons6 Parameters: Name Type Description Default filepath str Path to an OTF or TTF file containing the fonts required prefix str A prefix that will represent this font file when used for lookup. For example, 'fa5s' for 'Font-Awesome 5 Solid'. required charmap Dict [ str , str ], optional optional mapping for all of the glyph names to their unicode numbers. See note above. None Returns: Type Description Tuple [ str , str ], optional font-family and font-style for the file just registered, or None if something goes wrong.","title":"addFont()"},{"location":"utilities/fonticon/#animations","text":"the animation parameter to icon() accepts a subclass of Animation that will be","title":"Animations"},{"location":"utilities/fonticon/#superqt.fonticon.Animation","text":"Bases: ABC Base icon animation class.","title":"Animation"},{"location":"utilities/fonticon/#superqt.fonticon._animations.Animation.animate","text":"Setup and start the timer for the animation.","title":"animate()"},{"location":"utilities/fonticon/#superqt.fonticon.pulse","text":"Bases: spin Animation that spins an icon in slower, discrete steps.","title":"pulse"},{"location":"utilities/fonticon/#superqt.fonticon.spin","text":"Bases: Animation Animation that smoothly spins an icon.","title":"spin"},{"location":"utilities/qmessagehandler/","text":"QMessageHandler superqt.utils.QMessageHandler A context manager to intercept messages from Qt. Parameters: Name Type Description Default logger logging . Logger , optional If provided, intercepted messages will be logged with logger at the corresponding python log level, by default None None Attributes: Name Type Description records list of tuple Captured messages. This is a 3-tuple of: (log_level: int, message: str, context: dict) Examples: >>> handler = QMessageHandler () >>> handler . install () # now all Qt output will be available at mh.records >>> with QMessageHandler () as handler : # temporarily install ... ... >>> logger = logging . getLogger ( __name__ ) >>> with QMessageHandler ( logger ): # re-reoute Qt messages to a python logger. ... ... __enter__ () Enter a context with this handler installed install () Install this handler (override the current QtMessageHandler). uninstall () Uninstall this handler, restoring the previous handler.","title":"QMessageHandler"},{"location":"utilities/qmessagehandler/#qmessagehandler","text":"","title":"QMessageHandler"},{"location":"utilities/qmessagehandler/#superqt.utils.QMessageHandler","text":"A context manager to intercept messages from Qt. Parameters: Name Type Description Default logger logging . Logger , optional If provided, intercepted messages will be logged with logger at the corresponding python log level, by default None None Attributes: Name Type Description records list of tuple Captured messages. This is a 3-tuple of: (log_level: int, message: str, context: dict) Examples: >>> handler = QMessageHandler () >>> handler . install () # now all Qt output will be available at mh.records >>> with QMessageHandler () as handler : # temporarily install ... ... >>> logger = logging . getLogger ( __name__ ) >>> with QMessageHandler ( logger ): # re-reoute Qt messages to a python logger. ... ...","title":"QMessageHandler"},{"location":"utilities/qmessagehandler/#superqt.utils._message_handler.QMessageHandler.__enter__","text":"Enter a context with this handler installed","title":"__enter__()"},{"location":"utilities/qmessagehandler/#superqt.utils._message_handler.QMessageHandler.install","text":"Install this handler (override the current QtMessageHandler).","title":"install()"},{"location":"utilities/qmessagehandler/#superqt.utils._message_handler.QMessageHandler.uninstall","text":"Uninstall this handler, restoring the previous handler.","title":"uninstall()"},{"location":"utilities/thread_decorators/","text":"Threading decorators superqt provides two decorators that help to ensure that given function is running in the desired thread: ensure_main_thread ensure_main_thread ensures that the decorated function/method runs in the main thread ensure_object_thread ensure_object_thread ensures that a decorated bound method of a QObject runs in the thread in which the instance lives ( see qt documentation for details ). Usage By default, functions are executed asynchronously (they return immediately with an instance of concurrent.futures.Future ). To block and wait for the result, see Synchronous mode from qtpy.QtCore import QObject from superqt import ensure_main_thread , ensure_object_thread @ensure_main_thread def sample_function (): print ( \"This function will run in main thread\" ) class SampleObject ( QObject ): def __init__ ( self ): super () . __init__ () self . _value = 1 @ensure_main_thread def sample_method1 ( self ): print ( \"This method will run in main thread\" ) @ensure_object_thread def sample_method3 ( self ): import time print ( \"sleeping\" ) time . sleep ( 1 ) print ( \"This method will run in object thread\" ) @property def value ( self ): print ( \"return value\" ) return self . _value @value . setter @ensure_object_thread def value ( self , value ): print ( \"this setter will run in object thread\" ) self . _value = value As can be seen in this example these decorators can also be used for setters. These decorators should not be used as replacement of Qt Signals but rather to interact with Qt objects from non Qt code. Synchronous mode If you'd like for the program to block and wait for the result of your function call, use the await_return=True parameter, and optionally specify a timeout. Important Using synchronous mode may significantly impact performance. from superqt import ensure_main_thread @ensure_main_thread def sample_function1 (): return 1 @ensure_main_thread ( await_return = True ) def sample_function2 (): return 2 assert sample_function1 () is None assert sample_function2 () == 2 # optionally, specify a timeout @ensure_main_thread ( await_return = True , timeout = 10000 ) def sample_function (): return 1","title":"Threading decorators"},{"location":"utilities/thread_decorators/#threading-decorators","text":"superqt provides two decorators that help to ensure that given function is running in the desired thread:","title":"Threading decorators"},{"location":"utilities/thread_decorators/#ensure_main_thread","text":"ensure_main_thread ensures that the decorated function/method runs in the main thread","title":"ensure_main_thread"},{"location":"utilities/thread_decorators/#ensure_object_thread","text":"ensure_object_thread ensures that a decorated bound method of a QObject runs in the thread in which the instance lives ( see qt documentation for details ).","title":"ensure_object_thread"},{"location":"utilities/thread_decorators/#usage","text":"By default, functions are executed asynchronously (they return immediately with an instance of concurrent.futures.Future ). To block and wait for the result, see Synchronous mode from qtpy.QtCore import QObject from superqt import ensure_main_thread , ensure_object_thread @ensure_main_thread def sample_function (): print ( \"This function will run in main thread\" ) class SampleObject ( QObject ): def __init__ ( self ): super () . __init__ () self . _value = 1 @ensure_main_thread def sample_method1 ( self ): print ( \"This method will run in main thread\" ) @ensure_object_thread def sample_method3 ( self ): import time print ( \"sleeping\" ) time . sleep ( 1 ) print ( \"This method will run in object thread\" ) @property def value ( self ): print ( \"return value\" ) return self . _value @value . setter @ensure_object_thread def value ( self , value ): print ( \"this setter will run in object thread\" ) self . _value = value As can be seen in this example these decorators can also be used for setters. These decorators should not be used as replacement of Qt Signals but rather to interact with Qt objects from non Qt code.","title":"Usage"},{"location":"utilities/thread_decorators/#synchronous-mode","text":"If you'd like for the program to block and wait for the result of your function call, use the await_return=True parameter, and optionally specify a timeout. Important Using synchronous mode may significantly impact performance. from superqt import ensure_main_thread @ensure_main_thread def sample_function1 (): return 1 @ensure_main_thread ( await_return = True ) def sample_function2 (): return 2 assert sample_function1 () is None assert sample_function2 () == 2 # optionally, specify a timeout @ensure_main_thread ( await_return = True , timeout = 10000 ) def sample_function (): return 1","title":"Synchronous mode"},{"location":"utilities/threading/","text":"Thread workers The objects in this module provide utilities for running tasks in a separate thread. In general (with the exception of new_worker_qthread ), everything here wraps Qt's QRunnable API . The highest level object is the @thread_worker decorator. It was originally written for napari , and was later extracted into superqt . You may also be interested in reading the napari documentation on this feature, which provides a more in-depth/introductory usage guide. For additional control, you can create your own FunctionWorker or GeneratorWorker objects. superqt.utils.WorkerBase Bases: QRunnable , Generic [ _R ] Base class for creating a Worker that can run in another thread. Parameters: Name Type Description Default SignalsClass type , optional A QObject subclass that contains signals, by default WorkerBaseSignals WorkerBaseSignals Attributes: Name Type Description signals WorkerBaseSignals signal emitter object. To allow identify which worker thread emitted signal. __getattr__ ( name ) Pass through attr requests to signals to simplify connection API. The goal is to enable worker.yielded.connect instead of worker.signals.yielded.connect . Because multiple inheritance of Qt classes is not well supported in PyQt, we have to use composition here (signals are provided by QObjects, and QRunnable is not a QObject). So this passthrough allows us to connect to signals on the _signals object. abort_requested () property Whether the worker has been requested to stop. await_workers ( msecs = None ) classmethod Ask all workers to quit, and wait up to msec for quit. Attempts to clean up all running workers by calling worker.quit() method. Any workers in the WorkerBase._worker_set set will have this method. By default, this function will block indefinitely, until worker threads finish. If a timeout is provided, a RuntimeError will be raised if the workers do not gracefully exit in the time requests, but the threads will NOT be killed. It is (currently) left to the user to use their OS to force-quit rogue threads. Important If the user does not put any yields in their function, and the function is super long, it will just hang... For instance, there's no graceful way to kill this thread in python: @thread_worker def ZZZzzz (): time . sleep ( 10000000 ) This is why it's always advisable to use a generator that periodically yields for long-running computations in another thread. See this stack-overflow post for a good discussion on the difficulty of killing a rogue python thread: Parameters: Name Type Description Default msecs int , optional Waits up to msecs milliseconds for all threads to exit and removes all threads from the thread pool. If msecs is None (the default), the timeout is ignored (waits for the last thread to exit). None Raises: Type Description RuntimeError If a timeout is provided and workers do not quit successfully within the time allotted. is_running () property Whether the worker has been started quit () Send a request to abort the worker. Note It is entirely up to subclasses to honor this method by checking self.abort_requested periodically in their worker.work method, and exiting if True . run () Start the worker. The end-user should never need to call this function. But it cannot be made private or renamed, since it is called by Qt. The order of method calls when starting a worker is: calls QThreadPool.globalInstance().start(worker) | triggered by the QThreadPool.start() method | | called by worker.run | | | V V V worker.start -> worker.run -> worker.work This is the function that actually gets called when calling QThreadPool.start(worker) . It simply wraps the work() method, and emits a few signals. Subclasses should NOT override this method (except with good reason), and instead should implement work() . start () Start this worker in a thread and add it to the global threadpool. The order of method calls when starting a worker is: calls QThreadPool.globalInstance().start(worker) | triggered by the QThreadPool.start() method | | called by worker.run | | | V V V worker.start -> worker.run -> worker.work work () Main method to execute the worker. The end-user should never need to call this function. But subclasses must implement this method (See GeneratorFunction.work for an example implementation). Minimally, it should check self.abort_requested periodically and exit if True. Examples: class MyWorker ( WorkerBase ): def work ( self ): i = 0 while True : if self . abort_requested : self . aborted . emit () break i += 1 if i > max_iters : break time . sleep ( 0.5 ) superqt.utils.FunctionWorker Bases: WorkerBase [ _R ] QRunnable with signals that wraps a simple long-running function. Note FunctionWorker does not provide a way to stop a very long-running function (e.g. time.sleep(10000) ). So whenever possible, it is better to implement your long running function as a generator that yields periodically, and use the GeneratorWorker instead. Parameters: Name Type Description Default func Callable A function to call in another thread required *args will be passed to the function () **kwargs will be passed to the function {} Raises: Type Description TypeError If func is a generator function and not a regular function. superqt.utils.GeneratorWorker Bases: WorkerBase , Generic [ _Y , _S , _R ] QRunnable with signals that wraps a long-running generator. Provides a convenient way to run a generator function in another thread, while allowing 2-way communication between threads, using plain-python generator syntax in the original function. Parameters: Name Type Description Default func callable The function being run in another thread. May be a generator function. required SignalsClass type , optional A QObject subclass that contains signals, by default GeneratorWorkerSignals GeneratorWorkerSignals *args Will be passed to func on instantiation () **kwargs Will be passed to func on instantiation {} is_paused () property Whether the worker is currently paused. pause () Request to pause the worker. resume () Send a request to resume the worker. send ( value ) Send a value into the function (if a generator was used). toggle_pause () Request to pause the worker if playing or resume if paused. work () Core event loop that calls the original function. Enters a continual loop, yielding and returning from the original function. Checks for various events (quit, pause, resume, etc...). (To clarify: we are creating a rudimentary event loop here because there IS NO Qt event loop running in the other thread to hook into) Convenience functions superqt . utils . thread_worker ( function = None , start_thread = None , connect = None , worker_class = None , ignore_errors = False ) Decorator that runs a function in a separate thread when called. When called, the decorated function returns a WorkerBase . See create_worker for additional keyword arguments that can be used when calling the function. The returned worker will have these signals: started : emitted when the work is started finished : emitted when the work is finished returned : emitted with return value errored : emitted with error object on Exception It will also have a worker.start() method that can be used to start execution of the function in another thread. (useful if you need to connect callbacks to signals prior to execution) If the decorated function is a generator, the returned worker will also provide these signals: yielded : emitted with yielded values paused : emitted when a running job has successfully paused resumed : emitted when a paused job has successfully resumed aborted : emitted when a running job is successfully aborted And these methods: quit : ask the thread to quit toggle_paused : toggle the running state of the thread. send : send a value into the generator. (This requires that your decorator function uses the value = yield syntax) Parameters: Name Type Description Default function callable Function to call in another thread. For communication between threads may be a generator function. None start_thread bool Whether to immediaetly start the thread. If False, the returned worker must be manually started with worker.start() . by default it will be False if the _connect argument is None , otherwise True . None connect Dict [ str , Union [ Callable , Sequence ]] A mapping of \"signal_name\" -> callable or list of callable : callback functions to connect to the various signals offered by the worker class. by default None None worker_class Type [ WorkerBase ] The WorkerBase to instantiate, by default FunctionWorker will be used if func is a regular function, and GeneratorWorker will be used if it is a generator. None ignore_errors bool If False (the default), errors raised in the other thread will be reraised in the main thread (makes debugging significantly easier). False Returns: Type Description callable function that creates a worker, puts it in a new thread and returns the worker instance. Examples: @thread_worker def long_function ( start , end ): # do work, periodically yielding i = start while i <= end : time . sleep ( 0.1 ) yield i # do teardown return 'anything' # call the function to start running in another thread. worker = long_function () # connect signals here if desired... or they may be added using the # `connect` argument in the `@thread_worker` decorator... in which # case the worker will start immediately when long_function() is called worker . start () superqt . utils . create_worker ( func , * args , _start_thread = None , _connect = None , _worker_class = None , _ignore_errors = False , ** kwargs ) Convenience function to start a function in another thread. By default, uses FunctionWorker for functions and GeneratorWorker for generators, but a custom WorkerBase subclass may be provided. If so, it must be a subclass of WorkerBase , which defines a standard set of signals and a run method. Parameters: Name Type Description Default func Callable The function to call in another thread. required _start_thread bool Whether to immediaetly start the thread. If False, the returned worker must be manually started with worker.start() . by default it will be False if the _connect argument is None , otherwise True . None _connect Dict [ str , Union [ Callable , Sequence ]], optional A mapping of \"signal_name\" -> callable or list of callable : callback functions to connect to the various signals offered by the worker class. by default None None _worker_class type of The WorkerBase to instantiate, by default FunctionWorker will be used if func is a regular function, and GeneratorWorker will be used if it is a generator. None _ignore_errors bool If False (the default), errors raised in the other thread will be reraised in the main thread (makes debugging significantly easier). False *args will be passed to func () **kwargs will be passed to func {} Returns: Name Type Description worker WorkerBase An instantiated worker. If _start_thread was False , the worker will have a .start() method that can be used to start the thread. Raises: Type Description TypeError If a worker_class is provided that is not a subclass of WorkerBase. TypeError If _connect is provided and is not a dict of {str: callable} Examples: def long_function ( duration ): import time time . sleep ( duration ) worker = create_worker ( long_function , 10 ) superqt . utils . new_worker_qthread ( Worker , * args , _start_thread = False , _connect = None , ** kwargs ) This is a convenience function to start a worker in a QThread . In most cases, the thread_worker decorator is sufficient and preferable. But this allows the user to completely customize the Worker object. However, they must then maintain control over the thread and clean up appropriately. It follows the pattern described here and in the qt thread docs see also: https://mayaposch.wordpress.com/2011/11/01/how-to-really-truly-use-qthreads-the-full-explanation/ A QThread object is not a thread! It should be thought of as a class to manage a thread, not as the actual code or object that runs in that thread. The QThread object is created on the main thread and lives there. Worker objects which derive from QObject are the things that actually do the work. They can be moved to a QThread as is done here. Mostly ignorable detail While the signals/slots syntax of the worker looks very similar to standard \"single-threaded\" signals & slots, note that inter-thread signals and slots (automatically) use an event-based QueuedConnection, while intra-thread signals use a DirectConnection. See Signals and Slots Across Threads Parameters: Name Type Description Default Worker QObject QObject type that implements a work() method. The Worker should also emit a finished signal when the work is done. required _start_thread bool If True, thread will be started immediately, otherwise, thread must be manually started with thread.start(). False _connect dict Optional dictionary of {signal: function} to connect to the new worker. for instance: _connect = {'incremented': myfunc} will result in: worker.incremented.connect(myfunc) None *args will be passed to the Worker class on instantiation. () **kwargs will be passed to the Worker class on instantiation. {} Returns: Name Type Description worker WorkerBase The created worker. thread QThread The thread on which the worker is running. Examples: Create some QObject that has a long-running work method: class Worker ( QObject ): finished = Signal () increment = Signal ( int ) def __init__ ( self , argument ): super () . __init__ () self . argument = argument @Slot () def work ( self ): # some long running task... import time for i in range ( 10 ): time . sleep ( 1 ) self . increment . emit ( i ) self . finished . emit () worker , thread = new_worker_qthread ( Worker , 'argument' , _start_thread = True , _connect = { 'increment' : print }, )","title":"Thread workers"},{"location":"utilities/threading/#thread-workers","text":"The objects in this module provide utilities for running tasks in a separate thread. In general (with the exception of new_worker_qthread ), everything here wraps Qt's QRunnable API . The highest level object is the @thread_worker decorator. It was originally written for napari , and was later extracted into superqt . You may also be interested in reading the napari documentation on this feature, which provides a more in-depth/introductory usage guide. For additional control, you can create your own FunctionWorker or GeneratorWorker objects.","title":"Thread workers"},{"location":"utilities/threading/#superqt.utils.WorkerBase","text":"Bases: QRunnable , Generic [ _R ] Base class for creating a Worker that can run in another thread. Parameters: Name Type Description Default SignalsClass type , optional A QObject subclass that contains signals, by default WorkerBaseSignals WorkerBaseSignals Attributes: Name Type Description signals WorkerBaseSignals signal emitter object. To allow identify which worker thread emitted signal.","title":"WorkerBase"},{"location":"utilities/threading/#superqt.utils._qthreading.WorkerBase.__getattr__","text":"Pass through attr requests to signals to simplify connection API. The goal is to enable worker.yielded.connect instead of worker.signals.yielded.connect . Because multiple inheritance of Qt classes is not well supported in PyQt, we have to use composition here (signals are provided by QObjects, and QRunnable is not a QObject). So this passthrough allows us to connect to signals on the _signals object.","title":"__getattr__()"},{"location":"utilities/threading/#superqt.utils._qthreading.WorkerBase.abort_requested","text":"Whether the worker has been requested to stop.","title":"abort_requested()"},{"location":"utilities/threading/#superqt.utils._qthreading.WorkerBase.await_workers","text":"Ask all workers to quit, and wait up to msec for quit. Attempts to clean up all running workers by calling worker.quit() method. Any workers in the WorkerBase._worker_set set will have this method. By default, this function will block indefinitely, until worker threads finish. If a timeout is provided, a RuntimeError will be raised if the workers do not gracefully exit in the time requests, but the threads will NOT be killed. It is (currently) left to the user to use their OS to force-quit rogue threads. Important If the user does not put any yields in their function, and the function is super long, it will just hang... For instance, there's no graceful way to kill this thread in python: @thread_worker def ZZZzzz (): time . sleep ( 10000000 ) This is why it's always advisable to use a generator that periodically yields for long-running computations in another thread. See this stack-overflow post for a good discussion on the difficulty of killing a rogue python thread: Parameters: Name Type Description Default msecs int , optional Waits up to msecs milliseconds for all threads to exit and removes all threads from the thread pool. If msecs is None (the default), the timeout is ignored (waits for the last thread to exit). None Raises: Type Description RuntimeError If a timeout is provided and workers do not quit successfully within the time allotted.","title":"await_workers()"},{"location":"utilities/threading/#superqt.utils._qthreading.WorkerBase.is_running","text":"Whether the worker has been started","title":"is_running()"},{"location":"utilities/threading/#superqt.utils._qthreading.WorkerBase.quit","text":"Send a request to abort the worker. Note It is entirely up to subclasses to honor this method by checking self.abort_requested periodically in their worker.work method, and exiting if True .","title":"quit()"},{"location":"utilities/threading/#superqt.utils._qthreading.WorkerBase.run","text":"Start the worker. The end-user should never need to call this function. But it cannot be made private or renamed, since it is called by Qt. The order of method calls when starting a worker is: calls QThreadPool.globalInstance().start(worker) | triggered by the QThreadPool.start() method | | called by worker.run | | | V V V worker.start -> worker.run -> worker.work This is the function that actually gets called when calling QThreadPool.start(worker) . It simply wraps the work() method, and emits a few signals. Subclasses should NOT override this method (except with good reason), and instead should implement work() .","title":"run()"},{"location":"utilities/threading/#superqt.utils._qthreading.WorkerBase.start","text":"Start this worker in a thread and add it to the global threadpool. The order of method calls when starting a worker is: calls QThreadPool.globalInstance().start(worker) | triggered by the QThreadPool.start() method | | called by worker.run | | | V V V worker.start -> worker.run -> worker.work","title":"start()"},{"location":"utilities/threading/#superqt.utils._qthreading.WorkerBase.work","text":"Main method to execute the worker. The end-user should never need to call this function. But subclasses must implement this method (See GeneratorFunction.work for an example implementation). Minimally, it should check self.abort_requested periodically and exit if True. Examples: class MyWorker ( WorkerBase ): def work ( self ): i = 0 while True : if self . abort_requested : self . aborted . emit () break i += 1 if i > max_iters : break time . sleep ( 0.5 )","title":"work()"},{"location":"utilities/threading/#superqt.utils.FunctionWorker","text":"Bases: WorkerBase [ _R ] QRunnable with signals that wraps a simple long-running function. Note FunctionWorker does not provide a way to stop a very long-running function (e.g. time.sleep(10000) ). So whenever possible, it is better to implement your long running function as a generator that yields periodically, and use the GeneratorWorker instead. Parameters: Name Type Description Default func Callable A function to call in another thread required *args will be passed to the function () **kwargs will be passed to the function {} Raises: Type Description TypeError If func is a generator function and not a regular function.","title":"FunctionWorker"},{"location":"utilities/threading/#superqt.utils.GeneratorWorker","text":"Bases: WorkerBase , Generic [ _Y , _S , _R ] QRunnable with signals that wraps a long-running generator. Provides a convenient way to run a generator function in another thread, while allowing 2-way communication between threads, using plain-python generator syntax in the original function. Parameters: Name Type Description Default func callable The function being run in another thread. May be a generator function. required SignalsClass type , optional A QObject subclass that contains signals, by default GeneratorWorkerSignals GeneratorWorkerSignals *args Will be passed to func on instantiation () **kwargs Will be passed to func on instantiation {}","title":"GeneratorWorker"},{"location":"utilities/threading/#superqt.utils._qthreading.GeneratorWorker.is_paused","text":"Whether the worker is currently paused.","title":"is_paused()"},{"location":"utilities/threading/#superqt.utils._qthreading.GeneratorWorker.pause","text":"Request to pause the worker.","title":"pause()"},{"location":"utilities/threading/#superqt.utils._qthreading.GeneratorWorker.resume","text":"Send a request to resume the worker.","title":"resume()"},{"location":"utilities/threading/#superqt.utils._qthreading.GeneratorWorker.send","text":"Send a value into the function (if a generator was used).","title":"send()"},{"location":"utilities/threading/#superqt.utils._qthreading.GeneratorWorker.toggle_pause","text":"Request to pause the worker if playing or resume if paused.","title":"toggle_pause()"},{"location":"utilities/threading/#superqt.utils._qthreading.GeneratorWorker.work","text":"Core event loop that calls the original function. Enters a continual loop, yielding and returning from the original function. Checks for various events (quit, pause, resume, etc...). (To clarify: we are creating a rudimentary event loop here because there IS NO Qt event loop running in the other thread to hook into)","title":"work()"},{"location":"utilities/threading/#convenience-functions","text":"","title":"Convenience functions"},{"location":"utilities/threading/#superqt.utils.thread_worker","text":"Decorator that runs a function in a separate thread when called. When called, the decorated function returns a WorkerBase . See create_worker for additional keyword arguments that can be used when calling the function. The returned worker will have these signals: started : emitted when the work is started finished : emitted when the work is finished returned : emitted with return value errored : emitted with error object on Exception It will also have a worker.start() method that can be used to start execution of the function in another thread. (useful if you need to connect callbacks to signals prior to execution) If the decorated function is a generator, the returned worker will also provide these signals: yielded : emitted with yielded values paused : emitted when a running job has successfully paused resumed : emitted when a paused job has successfully resumed aborted : emitted when a running job is successfully aborted And these methods: quit : ask the thread to quit toggle_paused : toggle the running state of the thread. send : send a value into the generator. (This requires that your decorator function uses the value = yield syntax) Parameters: Name Type Description Default function callable Function to call in another thread. For communication between threads may be a generator function. None start_thread bool Whether to immediaetly start the thread. If False, the returned worker must be manually started with worker.start() . by default it will be False if the _connect argument is None , otherwise True . None connect Dict [ str , Union [ Callable , Sequence ]] A mapping of \"signal_name\" -> callable or list of callable : callback functions to connect to the various signals offered by the worker class. by default None None worker_class Type [ WorkerBase ] The WorkerBase to instantiate, by default FunctionWorker will be used if func is a regular function, and GeneratorWorker will be used if it is a generator. None ignore_errors bool If False (the default), errors raised in the other thread will be reraised in the main thread (makes debugging significantly easier). False Returns: Type Description callable function that creates a worker, puts it in a new thread and returns the worker instance. Examples: @thread_worker def long_function ( start , end ): # do work, periodically yielding i = start while i <= end : time . sleep ( 0.1 ) yield i # do teardown return 'anything' # call the function to start running in another thread. worker = long_function () # connect signals here if desired... or they may be added using the # `connect` argument in the `@thread_worker` decorator... in which # case the worker will start immediately when long_function() is called worker . start ()","title":"thread_worker()"},{"location":"utilities/threading/#superqt.utils.create_worker","text":"Convenience function to start a function in another thread. By default, uses FunctionWorker for functions and GeneratorWorker for generators, but a custom WorkerBase subclass may be provided. If so, it must be a subclass of WorkerBase , which defines a standard set of signals and a run method. Parameters: Name Type Description Default func Callable The function to call in another thread. required _start_thread bool Whether to immediaetly start the thread. If False, the returned worker must be manually started with worker.start() . by default it will be False if the _connect argument is None , otherwise True . None _connect Dict [ str , Union [ Callable , Sequence ]], optional A mapping of \"signal_name\" -> callable or list of callable : callback functions to connect to the various signals offered by the worker class. by default None None _worker_class type of The WorkerBase to instantiate, by default FunctionWorker will be used if func is a regular function, and GeneratorWorker will be used if it is a generator. None _ignore_errors bool If False (the default), errors raised in the other thread will be reraised in the main thread (makes debugging significantly easier). False *args will be passed to func () **kwargs will be passed to func {} Returns: Name Type Description worker WorkerBase An instantiated worker. If _start_thread was False , the worker will have a .start() method that can be used to start the thread. Raises: Type Description TypeError If a worker_class is provided that is not a subclass of WorkerBase. TypeError If _connect is provided and is not a dict of {str: callable} Examples: def long_function ( duration ): import time time . sleep ( duration ) worker = create_worker ( long_function , 10 )","title":"create_worker()"},{"location":"utilities/threading/#superqt.utils.new_worker_qthread","text":"This is a convenience function to start a worker in a QThread . In most cases, the thread_worker decorator is sufficient and preferable. But this allows the user to completely customize the Worker object. However, they must then maintain control over the thread and clean up appropriately. It follows the pattern described here and in the qt thread docs see also: https://mayaposch.wordpress.com/2011/11/01/how-to-really-truly-use-qthreads-the-full-explanation/ A QThread object is not a thread! It should be thought of as a class to manage a thread, not as the actual code or object that runs in that thread. The QThread object is created on the main thread and lives there. Worker objects which derive from QObject are the things that actually do the work. They can be moved to a QThread as is done here. Mostly ignorable detail While the signals/slots syntax of the worker looks very similar to standard \"single-threaded\" signals & slots, note that inter-thread signals and slots (automatically) use an event-based QueuedConnection, while intra-thread signals use a DirectConnection. See Signals and Slots Across Threads Parameters: Name Type Description Default Worker QObject QObject type that implements a work() method. The Worker should also emit a finished signal when the work is done. required _start_thread bool If True, thread will be started immediately, otherwise, thread must be manually started with thread.start(). False _connect dict Optional dictionary of {signal: function} to connect to the new worker. for instance: _connect = {'incremented': myfunc} will result in: worker.incremented.connect(myfunc) None *args will be passed to the Worker class on instantiation. () **kwargs will be passed to the Worker class on instantiation. {} Returns: Name Type Description worker WorkerBase The created worker. thread QThread The thread on which the worker is running. Examples: Create some QObject that has a long-running work method: class Worker ( QObject ): finished = Signal () increment = Signal ( int ) def __init__ ( self , argument ): super () . __init__ () self . argument = argument @Slot () def work ( self ): # some long running task... import time for i in range ( 10 ): time . sleep ( 1 ) self . increment . emit ( i ) self . finished . emit () worker , thread = new_worker_qthread ( Worker , 'argument' , _start_thread = True , _connect = { 'increment' : print }, )","title":"new_worker_qthread()"},{"location":"utilities/throttling/","text":"Throttling & Debouncing These utilities allow you to throttle or debounce a function. This is useful when you have a function that is called multiple times in a short period of time, and you want to make sure it is only \"actually\" called once (or at least no more than a certain frequency). For background on throttling and debouncing, see: https://blog.openreplay.com/forever-functional-debouncing-and-throttling-for-performance https://css-tricks.com/debouncing-throttling-explained-examples/ superqt . utils . qdebounced ( func = None , timeout = 100 , leading = False , timer_type = Qt . TimerType . PreciseTimer ) Creates a debounced function that delays invoking func . func will not be invoked until timeout ms have elapsed since the last time the debounced function was invoked. The debounced function comes with a cancel method to cancel delayed func invocations and a flush method to immediately invoke them. Options indicate whether func should be invoked on the leading and/or trailing edge of the wait timeout. The func is invoked with the last arguments provided to the debounced function. Subsequent calls to the debounced function return the result of the last func invocation. This decorator may be used with or without parameters. Parameters: Name Type Description Default func Callable A function to throttle None timeout int Timeout in milliseconds to wait before allowing another call, by default 100 100 leading bool Whether to invoke the function on the leading edge of the wait timer, by default False False timer_type Qt . TimerType The timer type. by default Qt.TimerType.PreciseTimer One of: - Qt.PreciseTimer : Precise timers try to keep millisecond accuracy - Qt.CoarseTimer : Coarse timers try to keep accuracy within 5% of the desired interval - Qt.VeryCoarseTimer : Very coarse timers only keep full second accuracy Qt.TimerType.PreciseTimer superqt . utils . qthrottled ( func = None , timeout = 100 , leading = True , timer_type = Qt . TimerType . PreciseTimer ) Creates a throttled function that invokes func at most once per timeout. The throttled function comes with a cancel method to cancel delayed func invocations and a flush method to immediately invoke them. Options to indicate whether func should be invoked on the leading and/or trailing edge of the wait timeout. The func is invoked with the last arguments provided to the throttled function. Subsequent calls to the throttled function return the result of the last func invocation. This decorator may be used with or without parameters. Parameters: Name Type Description Default func Callable A function to throttle None timeout int Timeout in milliseconds to wait before allowing another call, by default 100 100 leading bool Whether to invoke the function on the leading edge of the wait timer, by default True True timer_type Qt . TimerType The timer type. by default Qt.TimerType.PreciseTimer One of: - Qt.PreciseTimer : Precise timers try to keep millisecond accuracy - Qt.CoarseTimer : Coarse timers try to keep accuracy within 5% of the desired interval - Qt.VeryCoarseTimer : Very coarse timers only keep full second accuracy Qt.TimerType.PreciseTimer superqt.utils.QSignalDebouncer Bases: GenericSignalThrottler A Signal Debouncer. This object's triggered signal will not be emitted until self.timeout() milliseconds have elapsed since the last time triggered was emitted. superqt.utils.QSignalThrottler Bases: GenericSignalThrottler A Signal Throttler. This object's triggered signal will emit at most once per timeout (set with setTimeout()). superqt.utils._throttler.GenericSignalThrottler Bases: QObject cancel () Cancel any pending emissions. emissionPolicy () Return the emission policy (trailing or leading). flush () Force emission of any pending emissions. kind () Return the kind of throttler (throttler or debouncer). setTimeout ( timeout ) Set timeout in milliseconds setTimerType ( timerType ) Set current Qt.TimerType. throttle () Emit triggered if not running, then start timer. timeout () Return current timeout in milliseconds. timerType () Return current Qt.TimerType .","title":"Throttling & Debouncing"},{"location":"utilities/throttling/#throttling-debouncing","text":"These utilities allow you to throttle or debounce a function. This is useful when you have a function that is called multiple times in a short period of time, and you want to make sure it is only \"actually\" called once (or at least no more than a certain frequency). For background on throttling and debouncing, see: https://blog.openreplay.com/forever-functional-debouncing-and-throttling-for-performance https://css-tricks.com/debouncing-throttling-explained-examples/","title":"Throttling &amp; Debouncing"},{"location":"utilities/throttling/#superqt.utils.qdebounced","text":"Creates a debounced function that delays invoking func . func will not be invoked until timeout ms have elapsed since the last time the debounced function was invoked. The debounced function comes with a cancel method to cancel delayed func invocations and a flush method to immediately invoke them. Options indicate whether func should be invoked on the leading and/or trailing edge of the wait timeout. The func is invoked with the last arguments provided to the debounced function. Subsequent calls to the debounced function return the result of the last func invocation. This decorator may be used with or without parameters. Parameters: Name Type Description Default func Callable A function to throttle None timeout int Timeout in milliseconds to wait before allowing another call, by default 100 100 leading bool Whether to invoke the function on the leading edge of the wait timer, by default False False timer_type Qt . TimerType The timer type. by default Qt.TimerType.PreciseTimer One of: - Qt.PreciseTimer : Precise timers try to keep millisecond accuracy - Qt.CoarseTimer : Coarse timers try to keep accuracy within 5% of the desired interval - Qt.VeryCoarseTimer : Very coarse timers only keep full second accuracy Qt.TimerType.PreciseTimer","title":"qdebounced()"},{"location":"utilities/throttling/#superqt.utils.qthrottled","text":"Creates a throttled function that invokes func at most once per timeout. The throttled function comes with a cancel method to cancel delayed func invocations and a flush method to immediately invoke them. Options to indicate whether func should be invoked on the leading and/or trailing edge of the wait timeout. The func is invoked with the last arguments provided to the throttled function. Subsequent calls to the throttled function return the result of the last func invocation. This decorator may be used with or without parameters. Parameters: Name Type Description Default func Callable A function to throttle None timeout int Timeout in milliseconds to wait before allowing another call, by default 100 100 leading bool Whether to invoke the function on the leading edge of the wait timer, by default True True timer_type Qt . TimerType The timer type. by default Qt.TimerType.PreciseTimer One of: - Qt.PreciseTimer : Precise timers try to keep millisecond accuracy - Qt.CoarseTimer : Coarse timers try to keep accuracy within 5% of the desired interval - Qt.VeryCoarseTimer : Very coarse timers only keep full second accuracy Qt.TimerType.PreciseTimer","title":"qthrottled()"},{"location":"utilities/throttling/#superqt.utils.QSignalDebouncer","text":"Bases: GenericSignalThrottler A Signal Debouncer. This object's triggered signal will not be emitted until self.timeout() milliseconds have elapsed since the last time triggered was emitted.","title":"QSignalDebouncer"},{"location":"utilities/throttling/#superqt.utils.QSignalThrottler","text":"Bases: GenericSignalThrottler A Signal Throttler. This object's triggered signal will emit at most once per timeout (set with setTimeout()).","title":"QSignalThrottler"},{"location":"utilities/throttling/#superqt.utils._throttler.GenericSignalThrottler","text":"Bases: QObject","title":"GenericSignalThrottler"},{"location":"utilities/throttling/#superqt.utils._throttler.GenericSignalThrottler.cancel","text":"Cancel any pending emissions.","title":"cancel()"},{"location":"utilities/throttling/#superqt.utils._throttler.GenericSignalThrottler.emissionPolicy","text":"Return the emission policy (trailing or leading).","title":"emissionPolicy()"},{"location":"utilities/throttling/#superqt.utils._throttler.GenericSignalThrottler.flush","text":"Force emission of any pending emissions.","title":"flush()"},{"location":"utilities/throttling/#superqt.utils._throttler.GenericSignalThrottler.kind","text":"Return the kind of throttler (throttler or debouncer).","title":"kind()"},{"location":"utilities/throttling/#superqt.utils._throttler.GenericSignalThrottler.setTimeout","text":"Set timeout in milliseconds","title":"setTimeout()"},{"location":"utilities/throttling/#superqt.utils._throttler.GenericSignalThrottler.setTimerType","text":"Set current Qt.TimerType.","title":"setTimerType()"},{"location":"utilities/throttling/#superqt.utils._throttler.GenericSignalThrottler.throttle","text":"Emit triggered if not running, then start timer.","title":"throttle()"},{"location":"utilities/throttling/#superqt.utils._throttler.GenericSignalThrottler.timeout","text":"Return current timeout in milliseconds.","title":"timeout()"},{"location":"utilities/throttling/#superqt.utils._throttler.GenericSignalThrottler.timerType","text":"Return current Qt.TimerType .","title":"timerType()"},{"location":"widgets/","text":"Widgets The following are QWidget subclasses: Sliders and Numerical Inputs Widget Description QDoubleRangeSlider Multi-handle slider for float values QDoubleSlider Slider for float values QLabeledDoubleRangeSlider QDoubleRangeSlider variant with editable labels for each handle QLabeledDoubleSlider QSlider for float values with editable QSpinBox with the current value QLabeledRangeSlider QRangeSlider variant, with editable labels for each handle QLabeledSlider QSlider with editable QSpinBox that shows the current value QLargeIntSpinBox QSpinbox that accepts arbitrarily large integers QRangeSlider Multi-handle slider QQuantity Pint-backed quantity widget (magnitude combined with unit dropdown) Labels and categorical inputs Widget Description QElidingLabel A QLabel variant that will elide text (add \u2026 ) to fit width. QEnumComboBox QComboBox that populates the combobox from a python Enum QSearchableComboBox QComboBox variant that filters available options based on text input QSearchableListWidget QListWidget variant with search field that filters available options Frames and containers Widget Description QCollapsible A collapsible widget to hide and unhide child widgets.","title":"Widgets"},{"location":"widgets/#widgets","text":"The following are QWidget subclasses:","title":"Widgets"},{"location":"widgets/#sliders-and-numerical-inputs","text":"Widget Description QDoubleRangeSlider Multi-handle slider for float values QDoubleSlider Slider for float values QLabeledDoubleRangeSlider QDoubleRangeSlider variant with editable labels for each handle QLabeledDoubleSlider QSlider for float values with editable QSpinBox with the current value QLabeledRangeSlider QRangeSlider variant, with editable labels for each handle QLabeledSlider QSlider with editable QSpinBox that shows the current value QLargeIntSpinBox QSpinbox that accepts arbitrarily large integers QRangeSlider Multi-handle slider QQuantity Pint-backed quantity widget (magnitude combined with unit dropdown)","title":"Sliders and Numerical Inputs"},{"location":"widgets/#labels-and-categorical-inputs","text":"Widget Description QElidingLabel A QLabel variant that will elide text (add \u2026 ) to fit width. QEnumComboBox QComboBox that populates the combobox from a python Enum QSearchableComboBox QComboBox variant that filters available options based on text input QSearchableListWidget QListWidget variant with search field that filters available options","title":"Labels and categorical inputs"},{"location":"widgets/#frames-and-containers","text":"Widget Description QCollapsible A collapsible widget to hide and unhide child widgets.","title":"Frames and containers"},{"location":"widgets/qcollapsible/","text":"QCollapsible Collapsible QFrame that can be expanded or collapsed by clicking on the header. from qtpy.QtWidgets import QApplication , QLabel , QPushButton from superqt import QCollapsible app = QApplication ([]) collapsible = QCollapsible ( \"Advanced analysis\" ) collapsible . addWidget ( QLabel ( \"This is the inside of the collapsible frame\" )) for i in range ( 10 ): collapsible . addWidget ( QPushButton ( f \"Content button { i + 1 } \" )) collapsible . expand ( animate = False ) collapsible . show () app . exec_ () Qt Class QFrame Methods A collapsible widget to hide and unhide child widgets. Based on https://stackoverflow.com/a/68141638 addWidget ( widget : QWidget ) Add a widget to the central content widget's layout. collapse ( animate : bool = True ) Collapse (hide) the collapsible section content () -> QWidget Return the current content widget. expand ( animate : bool = True ) Expand (show) the collapsible section isExpanded () -> bool Return whether the collapsible section is visible locked () -> bool Return True if collapse/expand is disabled removeWidget ( widget : QWidget ) Remove widget from the central content widget's layout. setContent ( content : QWidget ) Replace central widget (the widget that gets expanded/collapsed). setDuration ( msecs : int ) Set duration of the collapse/expand animation. setEasingCurve ( easing : QEasingCurve ) Set the easing curve for the collapse/expand animation setLocked ( locked : bool = True ) Set whether collapse/expand is disabled setText ( text : str ) Set the text of the toggle button. text () -> str Return the text of the toggle button.","title":"QCollapsible"},{"location":"widgets/qcollapsible/#qcollapsible","text":"Collapsible QFrame that can be expanded or collapsed by clicking on the header. from qtpy.QtWidgets import QApplication , QLabel , QPushButton from superqt import QCollapsible app = QApplication ([]) collapsible = QCollapsible ( \"Advanced analysis\" ) collapsible . addWidget ( QLabel ( \"This is the inside of the collapsible frame\" )) for i in range ( 10 ): collapsible . addWidget ( QPushButton ( f \"Content button { i + 1 } \" )) collapsible . expand ( animate = False ) collapsible . show () app . exec_ ()","title":"QCollapsible"},{"location":"widgets/qcollapsible/#qt-class","text":"QFrame","title":"Qt Class"},{"location":"widgets/qcollapsible/#methods","text":"A collapsible widget to hide and unhide child widgets. Based on https://stackoverflow.com/a/68141638","title":"Methods"},{"location":"widgets/qcollapsible/#superqt.collapsible._collapsible.QCollapsible.addWidget","text":"Add a widget to the central content widget's layout.","title":"addWidget()"},{"location":"widgets/qcollapsible/#superqt.collapsible._collapsible.QCollapsible.collapse","text":"Collapse (hide) the collapsible section","title":"collapse()"},{"location":"widgets/qcollapsible/#superqt.collapsible._collapsible.QCollapsible.content","text":"Return the current content widget.","title":"content()"},{"location":"widgets/qcollapsible/#superqt.collapsible._collapsible.QCollapsible.expand","text":"Expand (show) the collapsible section","title":"expand()"},{"location":"widgets/qcollapsible/#superqt.collapsible._collapsible.QCollapsible.isExpanded","text":"Return whether the collapsible section is visible","title":"isExpanded()"},{"location":"widgets/qcollapsible/#superqt.collapsible._collapsible.QCollapsible.locked","text":"Return True if collapse/expand is disabled","title":"locked()"},{"location":"widgets/qcollapsible/#superqt.collapsible._collapsible.QCollapsible.removeWidget","text":"Remove widget from the central content widget's layout.","title":"removeWidget()"},{"location":"widgets/qcollapsible/#superqt.collapsible._collapsible.QCollapsible.setContent","text":"Replace central widget (the widget that gets expanded/collapsed).","title":"setContent()"},{"location":"widgets/qcollapsible/#superqt.collapsible._collapsible.QCollapsible.setDuration","text":"Set duration of the collapse/expand animation.","title":"setDuration()"},{"location":"widgets/qcollapsible/#superqt.collapsible._collapsible.QCollapsible.setEasingCurve","text":"Set the easing curve for the collapse/expand animation","title":"setEasingCurve()"},{"location":"widgets/qcollapsible/#superqt.collapsible._collapsible.QCollapsible.setLocked","text":"Set whether collapse/expand is disabled","title":"setLocked()"},{"location":"widgets/qcollapsible/#superqt.collapsible._collapsible.QCollapsible.setText","text":"Set the text of the toggle button.","title":"setText()"},{"location":"widgets/qcollapsible/#superqt.collapsible._collapsible.QCollapsible.text","text":"Return the text of the toggle button.","title":"text()"},{"location":"widgets/qdoublerangeslider/","text":"QDoubleRangeSlider Float variant of QRangeSlider . (see that page for more details). from qtpy.QtCore import Qt from qtpy.QtWidgets import QApplication from superqt import QDoubleRangeSlider app = QApplication ([]) slider = QDoubleRangeSlider ( Qt . Orientation . Horizontal ) slider . setRange ( 0 , 1 ) slider . setValue (( 0.2 , 0.8 )) slider . show () app . exec_ () Qt Class QSlider Methods","title":"QDoubleRangeSlider"},{"location":"widgets/qdoublerangeslider/#qdoublerangeslider","text":"Float variant of QRangeSlider . (see that page for more details). from qtpy.QtCore import Qt from qtpy.QtWidgets import QApplication from superqt import QDoubleRangeSlider app = QApplication ([]) slider = QDoubleRangeSlider ( Qt . Orientation . Horizontal ) slider . setRange ( 0 , 1 ) slider . setValue (( 0.2 , 0.8 )) slider . show () app . exec_ ()","title":"QDoubleRangeSlider"},{"location":"widgets/qdoublerangeslider/#qt-class","text":"QSlider","title":"Qt Class"},{"location":"widgets/qdoublerangeslider/#methods","text":"","title":"Methods"},{"location":"widgets/qdoubleslider/","text":"QDoubleSlider QSlider variant that accepts floating point values. from qtpy.QtCore import Qt from qtpy.QtWidgets import QApplication from superqt import QDoubleSlider app = QApplication ([]) slider = QDoubleSlider ( Qt . Orientation . Horizontal ) slider . setRange ( 0 , 1 ) slider . setValue ( 0.5 ) slider . show () app . exec_ () Qt Class QSlider Methods","title":"QDoubleSlider"},{"location":"widgets/qdoubleslider/#qdoubleslider","text":"QSlider variant that accepts floating point values. from qtpy.QtCore import Qt from qtpy.QtWidgets import QApplication from superqt import QDoubleSlider app = QApplication ([]) slider = QDoubleSlider ( Qt . Orientation . Horizontal ) slider . setRange ( 0 , 1 ) slider . setValue ( 0.5 ) slider . show () app . exec_ ()","title":"QDoubleSlider"},{"location":"widgets/qdoubleslider/#qt-class","text":"QSlider","title":"Qt Class"},{"location":"widgets/qdoubleslider/#methods","text":"","title":"Methods"},{"location":"widgets/qelidinglabel/","text":"QElidingLabel QLabel variant that will elide text (i.e. add an ellipsis) if it is too long to fit in the available space. from qtpy.QtWidgets import QApplication from superqt import QElidingLabel app = QApplication ([]) widget = QElidingLabel ( \"a skj skjfskfj sdlf sdfl sdlfk jsdf sdlkf jdsf dslfksdl sdlfk sdf sdl \" \"fjsdlf kjsdlfk laskdfsal as lsdfjdsl kfjdslf asfd dslkjfldskf sdlkfj\" ) widget . setWordWrap ( True ) widget . resize ( 300 , 20 ) widget . show () app . exec_ () Qt Class QLabel Methods A QLabel variant that will elide text (add '\u2026') to fit width. QElidingLabel() QElidingLabel(parent: Optional[QWidget], f: Qt.WindowFlags = ...) QElidingLabel(text: str, parent: Optional[QWidget] = None, f: Qt.WindowFlags = ...) For a multiline eliding label, use setWordWrap(True) . In this case, text will wrap to fit the width, and only the last line will be elided. When wordWrap() is True, sizeHint() will return the size required to fit the full text. elideMode () -> Qt . TextElideMode The current Qt.TextElideMode. setElideMode ( mode : Qt . TextElideMode ) Set the elide mode to a Qt.TextElideMode. wrapText ( text , width , font = None ) -> List [ str ] staticmethod Returns text , split as it would be wrapped for width , given font . Static method.","title":"QElidingLabel"},{"location":"widgets/qelidinglabel/#qelidinglabel","text":"QLabel variant that will elide text (i.e. add an ellipsis) if it is too long to fit in the available space. from qtpy.QtWidgets import QApplication from superqt import QElidingLabel app = QApplication ([]) widget = QElidingLabel ( \"a skj skjfskfj sdlf sdfl sdlfk jsdf sdlkf jdsf dslfksdl sdlfk sdf sdl \" \"fjsdlf kjsdlfk laskdfsal as lsdfjdsl kfjdslf asfd dslkjfldskf sdlkfj\" ) widget . setWordWrap ( True ) widget . resize ( 300 , 20 ) widget . show () app . exec_ ()","title":"QElidingLabel"},{"location":"widgets/qelidinglabel/#qt-class","text":"QLabel","title":"Qt Class"},{"location":"widgets/qelidinglabel/#methods","text":"A QLabel variant that will elide text (add '\u2026') to fit width. QElidingLabel() QElidingLabel(parent: Optional[QWidget], f: Qt.WindowFlags = ...) QElidingLabel(text: str, parent: Optional[QWidget] = None, f: Qt.WindowFlags = ...) For a multiline eliding label, use setWordWrap(True) . In this case, text will wrap to fit the width, and only the last line will be elided. When wordWrap() is True, sizeHint() will return the size required to fit the full text.","title":"Methods"},{"location":"widgets/qelidinglabel/#superqt._eliding_label.QElidingLabel.elideMode","text":"The current Qt.TextElideMode.","title":"elideMode()"},{"location":"widgets/qelidinglabel/#superqt._eliding_label.QElidingLabel.setElideMode","text":"Set the elide mode to a Qt.TextElideMode.","title":"setElideMode()"},{"location":"widgets/qelidinglabel/#superqt._eliding_label.QElidingLabel.wrapText","text":"Returns text , split as it would be wrapped for width , given font . Static method.","title":"wrapText()"},{"location":"widgets/qenumcombobox/","text":"QEnumComboBox QEnumComboBox is a variant of QComboBox that populates the items in the combobox based on a python Enum class. In addition to all the methods provided by QComboBox , this subclass adds the methods enumClass / setEnumClass to get/set the current Enum class represented by the combobox, and currentEnum / setCurrentEnum to get/set the current Enum member in the combobox. There is also a new signal currentEnumChanged(enum) analogous to currentIndexChanged and currentTextChanged . Method like insertItem and addItem are blocked and try of its usage will end with RuntimeError from enum import Enum from qtpy.QtWidgets import QApplication from superqt import QEnumComboBox class SampleEnum ( Enum ): first = 1 second = 2 third = 3 app = QApplication ([]) combo = QEnumComboBox () combo . setEnumClass ( SampleEnum ) combo . show () app . exec_ () Another option is to use optional enum_class argument of constructor and change # option A: combo = QEnumComboBox () combo . setEnumClass ( SampleEnum ) # option B: combo = QEnumComboBox ( enum_class = SampleEnum ) Allow None QEnumComboBox also allows using Optional type annotation: from enum import Enum from superqt import QEnumComboBox class SampleEnum ( Enum ): first = 1 second = 2 third = 3 # as usual: # you must create a QApplication before create a widget. combo = QEnumComboBox () combo . setEnumClass ( SampleEnum , allow_none = True ) In this case there is added option ---- and the currentEnum() method will return None when it is selected. Qt Class QComboBox Signals currentEnumChanged Methods ComboBox presenting options from a python Enum. If the Enum class does not implement __str__ then a human readable name is created from the name of the enum member, replacing underscores with spaces. currentEnum () -> Optional [ EnumType ] current value as Enum member enumClass () -> Optional [ EnumMeta ] return current Enum class isOptional () -> bool return if current enum is with optional annotation setCurrentEnum ( value : Optional [ EnumType ]) -> None Set value with Enum. setEnumClass ( enum : Optional [ EnumMeta ], allow_none = False ) Set enum class from which members value should be selected","title":"QEnumComboBox"},{"location":"widgets/qenumcombobox/#qenumcombobox","text":"QEnumComboBox is a variant of QComboBox that populates the items in the combobox based on a python Enum class. In addition to all the methods provided by QComboBox , this subclass adds the methods enumClass / setEnumClass to get/set the current Enum class represented by the combobox, and currentEnum / setCurrentEnum to get/set the current Enum member in the combobox. There is also a new signal currentEnumChanged(enum) analogous to currentIndexChanged and currentTextChanged . Method like insertItem and addItem are blocked and try of its usage will end with RuntimeError from enum import Enum from qtpy.QtWidgets import QApplication from superqt import QEnumComboBox class SampleEnum ( Enum ): first = 1 second = 2 third = 3 app = QApplication ([]) combo = QEnumComboBox () combo . setEnumClass ( SampleEnum ) combo . show () app . exec_ () Another option is to use optional enum_class argument of constructor and change # option A: combo = QEnumComboBox () combo . setEnumClass ( SampleEnum ) # option B: combo = QEnumComboBox ( enum_class = SampleEnum )","title":"QEnumComboBox"},{"location":"widgets/qenumcombobox/#allow-none","text":"QEnumComboBox also allows using Optional type annotation: from enum import Enum from superqt import QEnumComboBox class SampleEnum ( Enum ): first = 1 second = 2 third = 3 # as usual: # you must create a QApplication before create a widget. combo = QEnumComboBox () combo . setEnumClass ( SampleEnum , allow_none = True ) In this case there is added option ---- and the currentEnum() method will return None when it is selected.","title":"Allow None"},{"location":"widgets/qenumcombobox/#qt-class","text":"QComboBox","title":"Qt Class"},{"location":"widgets/qenumcombobox/#signals","text":"","title":"Signals"},{"location":"widgets/qenumcombobox/#currentenumchanged","text":"","title":"currentEnumChanged"},{"location":"widgets/qenumcombobox/#methods","text":"ComboBox presenting options from a python Enum. If the Enum class does not implement __str__ then a human readable name is created from the name of the enum member, replacing underscores with spaces.","title":"Methods"},{"location":"widgets/qenumcombobox/#superqt.combobox._enum_combobox.QEnumComboBox.currentEnum","text":"current value as Enum member","title":"currentEnum()"},{"location":"widgets/qenumcombobox/#superqt.combobox._enum_combobox.QEnumComboBox.enumClass","text":"return current Enum class","title":"enumClass()"},{"location":"widgets/qenumcombobox/#superqt.combobox._enum_combobox.QEnumComboBox.isOptional","text":"return if current enum is with optional annotation","title":"isOptional()"},{"location":"widgets/qenumcombobox/#superqt.combobox._enum_combobox.QEnumComboBox.setCurrentEnum","text":"Set value with Enum.","title":"setCurrentEnum()"},{"location":"widgets/qenumcombobox/#superqt.combobox._enum_combobox.QEnumComboBox.setEnumClass","text":"Set enum class from which members value should be selected","title":"setEnumClass()"},{"location":"widgets/qlabeleddoublerangeslider/","text":"QLabeledDoubleRangeSlider Labeled Float variant of QRangeSlider . (see that page for more details). from qtpy.QtCore import Qt from qtpy.QtWidgets import QApplication from superqt import QLabeledDoubleRangeSlider app = QApplication ([]) slider = QLabeledDoubleRangeSlider ( Qt . Orientation . Horizontal ) slider . setRange ( 0 , 1 ) slider . setValue (( 0.2 , 0.8 )) slider . show () app . exec_ () Qt Class QAbstractSlider Enums QLabeledDoubleRangeSlider.LabelPosition NoLabel LabelsAbove LabelsBelow QLabeledDoubleRangeSlider.EdgeLabelMode NoLabel LabelIsRange LabelIsValue Methods decimals () -> int setDecimals ( prec : int )","title":"QLabeledDoubleRangeSlider"},{"location":"widgets/qlabeleddoublerangeslider/#qlabeleddoublerangeslider","text":"Labeled Float variant of QRangeSlider . (see that page for more details). from qtpy.QtCore import Qt from qtpy.QtWidgets import QApplication from superqt import QLabeledDoubleRangeSlider app = QApplication ([]) slider = QLabeledDoubleRangeSlider ( Qt . Orientation . Horizontal ) slider . setRange ( 0 , 1 ) slider . setValue (( 0.2 , 0.8 )) slider . show () app . exec_ ()","title":"QLabeledDoubleRangeSlider"},{"location":"widgets/qlabeleddoublerangeslider/#qt-class","text":"QAbstractSlider","title":"Qt Class"},{"location":"widgets/qlabeleddoublerangeslider/#enums","text":"","title":"Enums"},{"location":"widgets/qlabeleddoublerangeslider/#qlabeleddoublerangesliderlabelposition","text":"NoLabel LabelsAbove LabelsBelow","title":"QLabeledDoubleRangeSlider.LabelPosition"},{"location":"widgets/qlabeleddoublerangeslider/#qlabeleddoublerangeslideredgelabelmode","text":"NoLabel LabelIsRange LabelIsValue","title":"QLabeledDoubleRangeSlider.EdgeLabelMode"},{"location":"widgets/qlabeleddoublerangeslider/#methods","text":"","title":"Methods"},{"location":"widgets/qlabeleddoublerangeslider/#superqt.sliders._labeled.QLabeledDoubleRangeSlider.decimals","text":"","title":"decimals()"},{"location":"widgets/qlabeleddoublerangeslider/#superqt.sliders._labeled.QLabeledDoubleRangeSlider.setDecimals","text":"","title":"setDecimals()"},{"location":"widgets/qlabeleddoubleslider/","text":"QLabeledDoubleSlider QDoubleSlider variant that shows an editable (SpinBox) label next to the slider. from qtpy.QtCore import Qt from qtpy.QtWidgets import QApplication from superqt import QLabeledDoubleSlider app = QApplication ([]) slider = QLabeledDoubleSlider ( Qt . Orientation . Horizontal ) slider . setRange ( 0 , 2.5 ) slider . setValue ( 1.3 ) slider . show () app . exec_ () Qt Class QAbstractSlider Enums QLabeledDoubleSlider.EdgeLabelMode NoLabel LabelIsRange LabelIsValue Methods decimals () -> int setDecimals ( prec : int )","title":"QLabeledDoubleSlider"},{"location":"widgets/qlabeleddoubleslider/#qlabeleddoubleslider","text":"QDoubleSlider variant that shows an editable (SpinBox) label next to the slider. from qtpy.QtCore import Qt from qtpy.QtWidgets import QApplication from superqt import QLabeledDoubleSlider app = QApplication ([]) slider = QLabeledDoubleSlider ( Qt . Orientation . Horizontal ) slider . setRange ( 0 , 2.5 ) slider . setValue ( 1.3 ) slider . show () app . exec_ ()","title":"QLabeledDoubleSlider"},{"location":"widgets/qlabeleddoubleslider/#qt-class","text":"QAbstractSlider","title":"Qt Class"},{"location":"widgets/qlabeleddoubleslider/#enums","text":"","title":"Enums"},{"location":"widgets/qlabeleddoubleslider/#qlabeleddoubleslideredgelabelmode","text":"NoLabel LabelIsRange LabelIsValue","title":"QLabeledDoubleSlider.EdgeLabelMode"},{"location":"widgets/qlabeleddoubleslider/#methods","text":"","title":"Methods"},{"location":"widgets/qlabeleddoubleslider/#superqt.sliders._labeled.QLabeledDoubleSlider.decimals","text":"","title":"decimals()"},{"location":"widgets/qlabeleddoubleslider/#superqt.sliders._labeled.QLabeledDoubleSlider.setDecimals","text":"","title":"setDecimals()"},{"location":"widgets/qlabeledrangeslider/","text":"QLabeledRangeSlider Labeled variant of QRangeSlider . (see that page for more details). from qtpy.QtCore import Qt from qtpy.QtWidgets import QApplication from superqt import QLabeledRangeSlider app = QApplication ([]) slider = QLabeledRangeSlider ( Qt . Orientation . Horizontal ) slider . setValue (( 20 , 80 )) slider . show () app . exec_ () Qt Class QAbstractSlider Signals editingFinished Enums QLabeledRangeSlider.LabelPosition NoLabel LabelsAbove LabelsBelow QLabeledRangeSlider.EdgeLabelMode NoLabel LabelIsRange LabelIsValue Methods edgeLabelMode () -> EdgeLabelMode Return current EdgeLabelMode . handleLabelPosition () -> LabelPosition Return where/whether labels are shown adjacent to slider handles. setEdgeLabelMode ( opt : EdgeLabelMode ) Set EdgeLabelMode , controls what is shown at the min/max labels. setHandleLabelPosition ( opt : LabelPosition ) -> LabelPosition Set where/whether labels are shown adjacent to slider handles. If you find that you need to fine tune the position of the handle labels: QLabeledRangeSlider.label_shift_x : adjust horizontal label position QLabeledRangeSlider.label_shift_y : adjust vertical label position","title":"QLabeledRangeSlider"},{"location":"widgets/qlabeledrangeslider/#qlabeledrangeslider","text":"Labeled variant of QRangeSlider . (see that page for more details). from qtpy.QtCore import Qt from qtpy.QtWidgets import QApplication from superqt import QLabeledRangeSlider app = QApplication ([]) slider = QLabeledRangeSlider ( Qt . Orientation . Horizontal ) slider . setValue (( 20 , 80 )) slider . show () app . exec_ ()","title":"QLabeledRangeSlider"},{"location":"widgets/qlabeledrangeslider/#qt-class","text":"QAbstractSlider","title":"Qt Class"},{"location":"widgets/qlabeledrangeslider/#signals","text":"","title":"Signals"},{"location":"widgets/qlabeledrangeslider/#editingfinished","text":"","title":"editingFinished"},{"location":"widgets/qlabeledrangeslider/#enums","text":"","title":"Enums"},{"location":"widgets/qlabeledrangeslider/#qlabeledrangesliderlabelposition","text":"NoLabel LabelsAbove LabelsBelow","title":"QLabeledRangeSlider.LabelPosition"},{"location":"widgets/qlabeledrangeslider/#qlabeledrangeslideredgelabelmode","text":"NoLabel LabelIsRange LabelIsValue","title":"QLabeledRangeSlider.EdgeLabelMode"},{"location":"widgets/qlabeledrangeslider/#methods","text":"","title":"Methods"},{"location":"widgets/qlabeledrangeslider/#superqt.sliders._labeled.QLabeledRangeSlider.edgeLabelMode","text":"Return current EdgeLabelMode .","title":"edgeLabelMode()"},{"location":"widgets/qlabeledrangeslider/#superqt.sliders._labeled.QLabeledRangeSlider.handleLabelPosition","text":"Return where/whether labels are shown adjacent to slider handles.","title":"handleLabelPosition()"},{"location":"widgets/qlabeledrangeslider/#superqt.sliders._labeled.QLabeledRangeSlider.setEdgeLabelMode","text":"Set EdgeLabelMode , controls what is shown at the min/max labels.","title":"setEdgeLabelMode()"},{"location":"widgets/qlabeledrangeslider/#superqt.sliders._labeled.QLabeledRangeSlider.setHandleLabelPosition","text":"Set where/whether labels are shown adjacent to slider handles. If you find that you need to fine tune the position of the handle labels: QLabeledRangeSlider.label_shift_x : adjust horizontal label position QLabeledRangeSlider.label_shift_y : adjust vertical label position","title":"setHandleLabelPosition()"},{"location":"widgets/qlabeledslider/","text":"QLabeledSlider QSlider variant that shows an editable (SpinBox) label next to the slider. from qtpy.QtCore import Qt from qtpy.QtWidgets import QApplication from superqt import QLabeledSlider app = QApplication ([]) slider = QLabeledSlider ( Qt . Orientation . Horizontal ) slider . setValue ( 42 ) slider . show () app . exec_ () Qt Class QAbstractSlider Signals editingFinished Enums QLabeledSlider.EdgeLabelMode NoLabel LabelIsRange LabelIsValue Methods edgeLabelMode () -> EdgeLabelMode Return current EdgeLabelMode . setEdgeLabelMode ( opt : EdgeLabelMode ) -> None Set the EdgeLabelMode .","title":"QLabeledSlider"},{"location":"widgets/qlabeledslider/#qlabeledslider","text":"QSlider variant that shows an editable (SpinBox) label next to the slider. from qtpy.QtCore import Qt from qtpy.QtWidgets import QApplication from superqt import QLabeledSlider app = QApplication ([]) slider = QLabeledSlider ( Qt . Orientation . Horizontal ) slider . setValue ( 42 ) slider . show () app . exec_ ()","title":"QLabeledSlider"},{"location":"widgets/qlabeledslider/#qt-class","text":"QAbstractSlider","title":"Qt Class"},{"location":"widgets/qlabeledslider/#signals","text":"","title":"Signals"},{"location":"widgets/qlabeledslider/#editingfinished","text":"","title":"editingFinished"},{"location":"widgets/qlabeledslider/#enums","text":"","title":"Enums"},{"location":"widgets/qlabeledslider/#qlabeledslideredgelabelmode","text":"NoLabel LabelIsRange LabelIsValue","title":"QLabeledSlider.EdgeLabelMode"},{"location":"widgets/qlabeledslider/#methods","text":"","title":"Methods"},{"location":"widgets/qlabeledslider/#superqt.sliders._labeled.QLabeledSlider.edgeLabelMode","text":"Return current EdgeLabelMode .","title":"edgeLabelMode()"},{"location":"widgets/qlabeledslider/#superqt.sliders._labeled.QLabeledSlider.setEdgeLabelMode","text":"Set the EdgeLabelMode .","title":"setEdgeLabelMode()"},{"location":"widgets/qlargeintspinbox/","text":"QLargeIntSpinBox QSpinBox variant that allows to enter large integers, without overflow. from qtpy.QtCore import Qt from qtpy.QtWidgets import QApplication from superqt import QLargeIntSpinBox app = QApplication ([]) slider = QLargeIntSpinBox () slider . setRange ( 0 , 4.53e8 ) slider . setValue ( 4.53e8 ) slider . show () app . exec_ () Qt Class QAbstractSpinBox Signals textChanged valueChanged Methods An integer spinboxes backed by unbound python integer Qt's built-in QSpinBox is backed by a signed 32-bit integer. This could become limiting, particularly in large dense segmentations. This class behaves like a QSpinBox backed by an unbound python int. Does not yet support \"prefix\", \"suffix\" or \"specialValue\" like QSpinBox. maximum () minimum () setMaximum ( max ) setMinimum ( min ) setRange ( minimum , maximum ) setSingleStep ( step ) setValue ( value ) singleStep () value ()","title":"QLargeIntSpinBox"},{"location":"widgets/qlargeintspinbox/#qlargeintspinbox","text":"QSpinBox variant that allows to enter large integers, without overflow. from qtpy.QtCore import Qt from qtpy.QtWidgets import QApplication from superqt import QLargeIntSpinBox app = QApplication ([]) slider = QLargeIntSpinBox () slider . setRange ( 0 , 4.53e8 ) slider . setValue ( 4.53e8 ) slider . show () app . exec_ ()","title":"QLargeIntSpinBox"},{"location":"widgets/qlargeintspinbox/#qt-class","text":"QAbstractSpinBox","title":"Qt Class"},{"location":"widgets/qlargeintspinbox/#signals","text":"","title":"Signals"},{"location":"widgets/qlargeintspinbox/#textchanged","text":"","title":"textChanged"},{"location":"widgets/qlargeintspinbox/#valuechanged","text":"","title":"valueChanged"},{"location":"widgets/qlargeintspinbox/#methods","text":"An integer spinboxes backed by unbound python integer Qt's built-in QSpinBox is backed by a signed 32-bit integer. This could become limiting, particularly in large dense segmentations. This class behaves like a QSpinBox backed by an unbound python int. Does not yet support \"prefix\", \"suffix\" or \"specialValue\" like QSpinBox.","title":"Methods"},{"location":"widgets/qlargeintspinbox/#superqt.spinbox._intspin.QLargeIntSpinBox.maximum","text":"","title":"maximum()"},{"location":"widgets/qlargeintspinbox/#superqt.spinbox._intspin.QLargeIntSpinBox.minimum","text":"","title":"minimum()"},{"location":"widgets/qlargeintspinbox/#superqt.spinbox._intspin.QLargeIntSpinBox.setMaximum","text":"","title":"setMaximum()"},{"location":"widgets/qlargeintspinbox/#superqt.spinbox._intspin.QLargeIntSpinBox.setMinimum","text":"","title":"setMinimum()"},{"location":"widgets/qlargeintspinbox/#superqt.spinbox._intspin.QLargeIntSpinBox.setRange","text":"","title":"setRange()"},{"location":"widgets/qlargeintspinbox/#superqt.spinbox._intspin.QLargeIntSpinBox.setSingleStep","text":"","title":"setSingleStep()"},{"location":"widgets/qlargeintspinbox/#superqt.spinbox._intspin.QLargeIntSpinBox.setValue","text":"","title":"setValue()"},{"location":"widgets/qlargeintspinbox/#superqt.spinbox._intspin.QLargeIntSpinBox.singleStep","text":"","title":"singleStep()"},{"location":"widgets/qlargeintspinbox/#superqt.spinbox._intspin.QLargeIntSpinBox.value","text":"","title":"value()"},{"location":"widgets/qquantity/","text":"QQuantity A widget that allows the user to edit a quantity (a magnitude associated with a unit). Note This widget requires pint : pip install pint or pip install superqt[quantity] from qtpy.QtWidgets import QApplication from superqt import QQuantity app = QApplication ([]) w = QQuantity ( \"1m\" ) w . show () app . exec () Qt Class QWidget Signals dimensionalityChanged unitsChanged valueChanged Methods A combination QDoubleSpinBox and QComboBox for entering quantities. For this widget, value() returns a pint.Quantity object, while setValue() accepts either a number, pint.Quantity , a string that can be parsed by pint . Parameters: Name Type Description Default value Union [ str , pint . Quantity , Number ] The initial value to display. If a string, it will be parsed by pint . 0 units Union [ pint . util . UnitsContainer , str , pint . Quantity ], optional The units to use if value is a number. If a string, it will be parsed by pint . If a pint.Quantity , the units will be extracted from it. None ureg pint . UnitRegistry , optional The unit registry to use. If not provided, the registry will be extracted from value if it is a pint.Quantity , otherwise the default registry will be used. None parent QWidget , optional The parent widget, by default None None dimensionality () -> UnitsContainer Return the current dimensionality (cast to str for nice repr). isDimensionless () -> bool Return True if the current value is dimensionless. magnitude () -> Union [ float , int ] Return the magnitude of the current value. magnitudeSpinBox () -> QDoubleSpinBox Return the QSpinBox widget used to edit the magnitude. setDecimals ( decimals : int ) -> None Set the number of decimals to display in the spinbox. setMagnitude ( magnitude : Number ) -> None Set the magnitude of the current value. setUnits ( units : Union [ str , Unit , Quantity ]) -> None Set the units of the current value. If units is None , will convert to a dimensionless quantity. Otherwise, units must be compatible with the current dimensionality. setValue ( value : Union [ str , Quantity , Number ], units : Union [ UnitsContainer , str , Quantity ] = None ) -> None Set the current value (will cast to a pint Quantity). text () -> str unitRegistry () -> UnitRegistry Return the pint UnitRegistry used by this widget. units () -> Unit Return the current units. unitsComboBox () -> QComboBox Return the QCombBox widget used to edit the units. value () -> Quantity Return the current value as a pint.Quantity .","title":"QQuantity"},{"location":"widgets/qquantity/#qquantity","text":"A widget that allows the user to edit a quantity (a magnitude associated with a unit). Note This widget requires pint : pip install pint or pip install superqt[quantity] from qtpy.QtWidgets import QApplication from superqt import QQuantity app = QApplication ([]) w = QQuantity ( \"1m\" ) w . show () app . exec ()","title":"QQuantity"},{"location":"widgets/qquantity/#qt-class","text":"QWidget","title":"Qt Class"},{"location":"widgets/qquantity/#signals","text":"","title":"Signals"},{"location":"widgets/qquantity/#dimensionalitychanged","text":"","title":"dimensionalityChanged"},{"location":"widgets/qquantity/#unitschanged","text":"","title":"unitsChanged"},{"location":"widgets/qquantity/#valuechanged","text":"","title":"valueChanged"},{"location":"widgets/qquantity/#methods","text":"A combination QDoubleSpinBox and QComboBox for entering quantities. For this widget, value() returns a pint.Quantity object, while setValue() accepts either a number, pint.Quantity , a string that can be parsed by pint . Parameters: Name Type Description Default value Union [ str , pint . Quantity , Number ] The initial value to display. If a string, it will be parsed by pint . 0 units Union [ pint . util . UnitsContainer , str , pint . Quantity ], optional The units to use if value is a number. If a string, it will be parsed by pint . If a pint.Quantity , the units will be extracted from it. None ureg pint . UnitRegistry , optional The unit registry to use. If not provided, the registry will be extracted from value if it is a pint.Quantity , otherwise the default registry will be used. None parent QWidget , optional The parent widget, by default None None","title":"Methods"},{"location":"widgets/qquantity/#superqt.spinbox._quantity.QQuantity.dimensionality","text":"Return the current dimensionality (cast to str for nice repr).","title":"dimensionality()"},{"location":"widgets/qquantity/#superqt.spinbox._quantity.QQuantity.isDimensionless","text":"Return True if the current value is dimensionless.","title":"isDimensionless()"},{"location":"widgets/qquantity/#superqt.spinbox._quantity.QQuantity.magnitude","text":"Return the magnitude of the current value.","title":"magnitude()"},{"location":"widgets/qquantity/#superqt.spinbox._quantity.QQuantity.magnitudeSpinBox","text":"Return the QSpinBox widget used to edit the magnitude.","title":"magnitudeSpinBox()"},{"location":"widgets/qquantity/#superqt.spinbox._quantity.QQuantity.setDecimals","text":"Set the number of decimals to display in the spinbox.","title":"setDecimals()"},{"location":"widgets/qquantity/#superqt.spinbox._quantity.QQuantity.setMagnitude","text":"Set the magnitude of the current value.","title":"setMagnitude()"},{"location":"widgets/qquantity/#superqt.spinbox._quantity.QQuantity.setUnits","text":"Set the units of the current value. If units is None , will convert to a dimensionless quantity. Otherwise, units must be compatible with the current dimensionality.","title":"setUnits()"},{"location":"widgets/qquantity/#superqt.spinbox._quantity.QQuantity.setValue","text":"Set the current value (will cast to a pint Quantity).","title":"setValue()"},{"location":"widgets/qquantity/#superqt.spinbox._quantity.QQuantity.text","text":"","title":"text()"},{"location":"widgets/qquantity/#superqt.spinbox._quantity.QQuantity.unitRegistry","text":"Return the pint UnitRegistry used by this widget.","title":"unitRegistry()"},{"location":"widgets/qquantity/#superqt.spinbox._quantity.QQuantity.units","text":"Return the current units.","title":"units()"},{"location":"widgets/qquantity/#superqt.spinbox._quantity.QQuantity.unitsComboBox","text":"Return the QCombBox widget used to edit the units.","title":"unitsComboBox()"},{"location":"widgets/qquantity/#superqt.spinbox._quantity.QQuantity.value","text":"Return the current value as a pint.Quantity .","title":"value()"},{"location":"widgets/qrangeslider/","text":"QRangeSlider A multi-handle slider widget than can be used to select a range of values. from qtpy.QtCore import Qt from qtpy.QtWidgets import QApplication from superqt import QRangeSlider app = QApplication ([]) slider = QRangeSlider ( Qt . Orientation . Horizontal ) slider . setValue (( 20 , 80 )) slider . show () app . exec_ () QRangeSlider inherits from QSlider and attempts to match the Qt API as closely as possible It uses platform-specific styles (for handle, groove, & ticks) but also supports QSS style sheets. Supports mouse wheel events Supports more than 2 handles (e.g. slider.setValue([0, 10, 60, 80]) ) As QRangeSlider inherits from QtWidgets.QSlider , you can use all of the same methods available in the QSlider API . The major difference is that value() and sliderPosition() are reimplemented as tuples of int (where the length of the tuple is equal to the number of handles in the slider.) These options are in addition to the Qt QSlider API, and control the behavior of the bar between handles. getter setter type default description barIsVisible setBarIsVisible hideBar / showBar bool True Whether the bar between handles is visible. barMovesAllHandles setBarMovesAllHandles bool True Whether clicking on the bar moves all handles or just the nearest barIsRigid setBarIsRigid bool True Whether bar length is constant or \"elastic\" when dragging the bar beyond min/max. Screenshots code that generates the images below import os from qtpy import QtCore from qtpy import QtWidgets as QtW # patch for Qt 5.15 on macos >= 12 os . environ [ \"USE_MAC_SLIDER_PATCH\" ] = \"1\" from superqt import QRangeSlider # noqa QSS = \"\"\" QSlider { min-height: 20px; } QSlider::groove:horizontal { border: 0px; background: qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 #888, stop:1 #ddd); height: 20px; border-radius: 10px; } QSlider::handle { background: qradialgradient(cx:0, cy:0, radius: 1.2, fx:0.35, fy:0.3, stop:0 #eef, stop:1 #002); height: 20px; width: 20px; border-radius: 10px; } QSlider::sub-page:horizontal { background: qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 #227, stop:1 #77a); border-top-left-radius: 10px; border-bottom-left-radius: 10px; } QRangeSlider { qproperty-barColor: qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 #227, stop:1 #77a); } \"\"\" Horizontal = QtCore . Qt . Orientation . Horizontal class DemoWidget ( QtW . QWidget ): def __init__ ( self ) -> None : super () . __init__ () reg_hslider = QtW . QSlider ( Horizontal ) reg_hslider . setValue ( 50 ) range_hslider = QRangeSlider ( Horizontal ) range_hslider . setValue (( 20 , 80 )) multi_range_hslider = QRangeSlider ( Horizontal ) multi_range_hslider . setValue (( 11 , 33 , 66 , 88 )) multi_range_hslider . setTickPosition ( QtW . QSlider . TickPosition . TicksAbove ) styled_reg_hslider = QtW . QSlider ( Horizontal ) styled_reg_hslider . setValue ( 50 ) styled_reg_hslider . setStyleSheet ( QSS ) styled_range_hslider = QRangeSlider ( Horizontal ) styled_range_hslider . setValue (( 20 , 80 )) styled_range_hslider . setStyleSheet ( QSS ) reg_vslider = QtW . QSlider ( QtCore . Qt . Orientation . Vertical ) reg_vslider . setValue ( 50 ) range_vslider = QRangeSlider ( QtCore . Qt . Orientation . Vertical ) range_vslider . setValue (( 22 , 77 )) tick_vslider = QtW . QSlider ( QtCore . Qt . Orientation . Vertical ) tick_vslider . setValue ( 55 ) tick_vslider . setTickPosition ( QtW . QSlider . TicksRight ) range_tick_vslider = QRangeSlider ( QtCore . Qt . Orientation . Vertical ) range_tick_vslider . setValue (( 22 , 77 )) range_tick_vslider . setTickPosition ( QtW . QSlider . TicksLeft ) szp = QtW . QSizePolicy . Maximum left = QtW . QWidget () left . setLayout ( QtW . QVBoxLayout ()) left . setContentsMargins ( 2 , 2 , 2 , 2 ) label1 = QtW . QLabel ( \"Regular QSlider Unstyled\" ) label2 = QtW . QLabel ( \"QRangeSliders Unstyled\" ) label3 = QtW . QLabel ( \"Styled Sliders (using same stylesheet)\" ) label1 . setSizePolicy ( szp , szp ) label2 . setSizePolicy ( szp , szp ) label3 . setSizePolicy ( szp , szp ) left . layout () . addWidget ( label1 ) left . layout () . addWidget ( reg_hslider ) left . layout () . addWidget ( label2 ) left . layout () . addWidget ( range_hslider ) left . layout () . addWidget ( multi_range_hslider ) left . layout () . addWidget ( label3 ) left . layout () . addWidget ( styled_reg_hslider ) left . layout () . addWidget ( styled_range_hslider ) right = QtW . QWidget () right . setLayout ( QtW . QHBoxLayout ()) right . setContentsMargins ( 15 , 5 , 5 , 0 ) right . layout () . setSpacing ( 30 ) right . layout () . addWidget ( reg_vslider ) right . layout () . addWidget ( range_vslider ) right . layout () . addWidget ( tick_vslider ) right . layout () . addWidget ( range_tick_vslider ) self . setLayout ( QtW . QHBoxLayout ()) self . layout () . addWidget ( left ) self . layout () . addWidget ( right ) self . setGeometry ( 600 , 300 , 580 , 300 ) self . activateWindow () self . show () if __name__ == \"__main__\" : import sys from pathlib import Path dest = Path ( \"screenshots\" ) dest . mkdir ( exist_ok = True ) app = QtW . QApplication ([]) demo = DemoWidget () if \"-snap\" in sys . argv : import platform QtW . QApplication . processEvents () demo . grab () . save ( str ( dest / f \"demo_ { platform . system () . lower () } .png\" )) else : app . exec_ () macOS Catalina Big Sur Windows Linux Qt Class QSlider Methods MultiHandle Range Slider widget. Same API as QSlider, but value , setValue , sliderPosition , and setSliderPosition are all sequences of integers. The valueChanged and sliderMoved signals also both emit a tuple of integers. barColor = Property ( QtGui . QBrush , _getBarColor , _setBarColor ) class-attribute The color of the bar between the first and last handle. applyMacStylePatch () -> str Apply a QSS patch to fix sliders on macos>=12 with QT < 6. see FAQ for more details. barIsRigid () -> bool Whether bar length is constant when dragging the bar. If False , the bar can shorten when dragged beyond min/max. Default is True . barIsVisible () -> bool Whether to show the bar between the first and last handle. barMovesAllHandles () -> bool Whether clicking on the bar moves all handles, or just the nearest. hideBar () -> None Hide the bar between the first and last handle. setBarIsRigid ( val : bool = True ) -> None Whether bar length is constant when dragging the bar. If False , the bar can shorten when dragged beyond min/max. Default is True . setBarMovesAllHandles ( val : bool = True ) -> None Whether clicking on the bar moves all handles, or just the nearest. setBarVisible ( val : bool = True ) -> None Whether to show the bar between the first and last handle. showBar () -> None Show the bar between the first and last handle. Type changes Note the following changes in types compared to the QSlider API: value () -> Tuple [ int , ... ] setValue ( val : Sequence [ int ]) -> None # Signal valueChanged ( Tuple [ int , ... ]) sliderPosition () -> Tuple [ int , ... ] setSliderPosition ( val : Sequence [ int ]) -> None sliderMoved ( Tuple [ int , ... ])","title":"QRangeSlider"},{"location":"widgets/qrangeslider/#qrangeslider","text":"A multi-handle slider widget than can be used to select a range of values. from qtpy.QtCore import Qt from qtpy.QtWidgets import QApplication from superqt import QRangeSlider app = QApplication ([]) slider = QRangeSlider ( Qt . Orientation . Horizontal ) slider . setValue (( 20 , 80 )) slider . show () app . exec_ () QRangeSlider inherits from QSlider and attempts to match the Qt API as closely as possible It uses platform-specific styles (for handle, groove, & ticks) but also supports QSS style sheets. Supports mouse wheel events Supports more than 2 handles (e.g. slider.setValue([0, 10, 60, 80]) ) As QRangeSlider inherits from QtWidgets.QSlider , you can use all of the same methods available in the QSlider API . The major difference is that value() and sliderPosition() are reimplemented as tuples of int (where the length of the tuple is equal to the number of handles in the slider.) These options are in addition to the Qt QSlider API, and control the behavior of the bar between handles. getter setter type default description barIsVisible setBarIsVisible hideBar / showBar bool True Whether the bar between handles is visible. barMovesAllHandles setBarMovesAllHandles bool True Whether clicking on the bar moves all handles or just the nearest barIsRigid setBarIsRigid bool True Whether bar length is constant or \"elastic\" when dragging the bar beyond min/max.","title":"QRangeSlider"},{"location":"widgets/qrangeslider/#screenshots","text":"code that generates the images below import os from qtpy import QtCore from qtpy import QtWidgets as QtW # patch for Qt 5.15 on macos >= 12 os . environ [ \"USE_MAC_SLIDER_PATCH\" ] = \"1\" from superqt import QRangeSlider # noqa QSS = \"\"\" QSlider { min-height: 20px; } QSlider::groove:horizontal { border: 0px; background: qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 #888, stop:1 #ddd); height: 20px; border-radius: 10px; } QSlider::handle { background: qradialgradient(cx:0, cy:0, radius: 1.2, fx:0.35, fy:0.3, stop:0 #eef, stop:1 #002); height: 20px; width: 20px; border-radius: 10px; } QSlider::sub-page:horizontal { background: qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 #227, stop:1 #77a); border-top-left-radius: 10px; border-bottom-left-radius: 10px; } QRangeSlider { qproperty-barColor: qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 #227, stop:1 #77a); } \"\"\" Horizontal = QtCore . Qt . Orientation . Horizontal class DemoWidget ( QtW . QWidget ): def __init__ ( self ) -> None : super () . __init__ () reg_hslider = QtW . QSlider ( Horizontal ) reg_hslider . setValue ( 50 ) range_hslider = QRangeSlider ( Horizontal ) range_hslider . setValue (( 20 , 80 )) multi_range_hslider = QRangeSlider ( Horizontal ) multi_range_hslider . setValue (( 11 , 33 , 66 , 88 )) multi_range_hslider . setTickPosition ( QtW . QSlider . TickPosition . TicksAbove ) styled_reg_hslider = QtW . QSlider ( Horizontal ) styled_reg_hslider . setValue ( 50 ) styled_reg_hslider . setStyleSheet ( QSS ) styled_range_hslider = QRangeSlider ( Horizontal ) styled_range_hslider . setValue (( 20 , 80 )) styled_range_hslider . setStyleSheet ( QSS ) reg_vslider = QtW . QSlider ( QtCore . Qt . Orientation . Vertical ) reg_vslider . setValue ( 50 ) range_vslider = QRangeSlider ( QtCore . Qt . Orientation . Vertical ) range_vslider . setValue (( 22 , 77 )) tick_vslider = QtW . QSlider ( QtCore . Qt . Orientation . Vertical ) tick_vslider . setValue ( 55 ) tick_vslider . setTickPosition ( QtW . QSlider . TicksRight ) range_tick_vslider = QRangeSlider ( QtCore . Qt . Orientation . Vertical ) range_tick_vslider . setValue (( 22 , 77 )) range_tick_vslider . setTickPosition ( QtW . QSlider . TicksLeft ) szp = QtW . QSizePolicy . Maximum left = QtW . QWidget () left . setLayout ( QtW . QVBoxLayout ()) left . setContentsMargins ( 2 , 2 , 2 , 2 ) label1 = QtW . QLabel ( \"Regular QSlider Unstyled\" ) label2 = QtW . QLabel ( \"QRangeSliders Unstyled\" ) label3 = QtW . QLabel ( \"Styled Sliders (using same stylesheet)\" ) label1 . setSizePolicy ( szp , szp ) label2 . setSizePolicy ( szp , szp ) label3 . setSizePolicy ( szp , szp ) left . layout () . addWidget ( label1 ) left . layout () . addWidget ( reg_hslider ) left . layout () . addWidget ( label2 ) left . layout () . addWidget ( range_hslider ) left . layout () . addWidget ( multi_range_hslider ) left . layout () . addWidget ( label3 ) left . layout () . addWidget ( styled_reg_hslider ) left . layout () . addWidget ( styled_range_hslider ) right = QtW . QWidget () right . setLayout ( QtW . QHBoxLayout ()) right . setContentsMargins ( 15 , 5 , 5 , 0 ) right . layout () . setSpacing ( 30 ) right . layout () . addWidget ( reg_vslider ) right . layout () . addWidget ( range_vslider ) right . layout () . addWidget ( tick_vslider ) right . layout () . addWidget ( range_tick_vslider ) self . setLayout ( QtW . QHBoxLayout ()) self . layout () . addWidget ( left ) self . layout () . addWidget ( right ) self . setGeometry ( 600 , 300 , 580 , 300 ) self . activateWindow () self . show () if __name__ == \"__main__\" : import sys from pathlib import Path dest = Path ( \"screenshots\" ) dest . mkdir ( exist_ok = True ) app = QtW . QApplication ([]) demo = DemoWidget () if \"-snap\" in sys . argv : import platform QtW . QApplication . processEvents () demo . grab () . save ( str ( dest / f \"demo_ { platform . system () . lower () } .png\" )) else : app . exec_ ()","title":"Screenshots"},{"location":"widgets/qrangeslider/#macos","text":"","title":"macOS"},{"location":"widgets/qrangeslider/#catalina","text":"","title":"Catalina"},{"location":"widgets/qrangeslider/#big-sur","text":"","title":"Big Sur"},{"location":"widgets/qrangeslider/#windows","text":"","title":"Windows"},{"location":"widgets/qrangeslider/#linux","text":"","title":"Linux"},{"location":"widgets/qrangeslider/#qt-class","text":"QSlider","title":"Qt Class"},{"location":"widgets/qrangeslider/#methods","text":"MultiHandle Range Slider widget. Same API as QSlider, but value , setValue , sliderPosition , and setSliderPosition are all sequences of integers. The valueChanged and sliderMoved signals also both emit a tuple of integers.","title":"Methods"},{"location":"widgets/qrangeslider/#superqt.sliders._generic_range_slider._GenericRangeSlider.barColor","text":"The color of the bar between the first and last handle.","title":"barColor"},{"location":"widgets/qrangeslider/#superqt.sliders._generic_range_slider._GenericRangeSlider.applyMacStylePatch","text":"Apply a QSS patch to fix sliders on macos>=12 with QT < 6. see FAQ for more details.","title":"applyMacStylePatch()"},{"location":"widgets/qrangeslider/#superqt.sliders._generic_range_slider._GenericRangeSlider.barIsRigid","text":"Whether bar length is constant when dragging the bar. If False , the bar can shorten when dragged beyond min/max. Default is True .","title":"barIsRigid()"},{"location":"widgets/qrangeslider/#superqt.sliders._generic_range_slider._GenericRangeSlider.barIsVisible","text":"Whether to show the bar between the first and last handle.","title":"barIsVisible()"},{"location":"widgets/qrangeslider/#superqt.sliders._generic_range_slider._GenericRangeSlider.barMovesAllHandles","text":"Whether clicking on the bar moves all handles, or just the nearest.","title":"barMovesAllHandles()"},{"location":"widgets/qrangeslider/#superqt.sliders._generic_range_slider._GenericRangeSlider.hideBar","text":"Hide the bar between the first and last handle.","title":"hideBar()"},{"location":"widgets/qrangeslider/#superqt.sliders._generic_range_slider._GenericRangeSlider.setBarIsRigid","text":"Whether bar length is constant when dragging the bar. If False , the bar can shorten when dragged beyond min/max. Default is True .","title":"setBarIsRigid()"},{"location":"widgets/qrangeslider/#superqt.sliders._generic_range_slider._GenericRangeSlider.setBarMovesAllHandles","text":"Whether clicking on the bar moves all handles, or just the nearest.","title":"setBarMovesAllHandles()"},{"location":"widgets/qrangeslider/#superqt.sliders._generic_range_slider._GenericRangeSlider.setBarVisible","text":"Whether to show the bar between the first and last handle.","title":"setBarVisible()"},{"location":"widgets/qrangeslider/#superqt.sliders._generic_range_slider._GenericRangeSlider.showBar","text":"Show the bar between the first and last handle.","title":"showBar()"},{"location":"widgets/qrangeslider/#type-changes","text":"Note the following changes in types compared to the QSlider API: value () -> Tuple [ int , ... ] setValue ( val : Sequence [ int ]) -> None # Signal valueChanged ( Tuple [ int , ... ]) sliderPosition () -> Tuple [ int , ... ] setSliderPosition ( val : Sequence [ int ]) -> None sliderMoved ( Tuple [ int , ... ])","title":"Type changes"},{"location":"widgets/qsearchablecombobox/","text":"QSearchableComboBox QSearchableComboBox is a variant of QComboBox that allow to filter list of options by enter part of text. It could be drop in replacement for QComboBox . from qtpy.QtWidgets import QApplication from superqt import QSearchableComboBox app = QApplication ([]) combo = QSearchableComboBox () combo . addItems ([ \"foo\" , \"bar\" , \"baz\" , \"foobar\" , \"foobaz\" , \"barbaz\" ]) combo . show () app . exec_ () Qt Class QComboBox","title":"QSearchableComboBox"},{"location":"widgets/qsearchablecombobox/#qsearchablecombobox","text":"QSearchableComboBox is a variant of QComboBox that allow to filter list of options by enter part of text. It could be drop in replacement for QComboBox . from qtpy.QtWidgets import QApplication from superqt import QSearchableComboBox app = QApplication ([]) combo = QSearchableComboBox () combo . addItems ([ \"foo\" , \"bar\" , \"baz\" , \"foobar\" , \"foobaz\" , \"barbaz\" ]) combo . show () app . exec_ ()","title":"QSearchableComboBox"},{"location":"widgets/qsearchablecombobox/#qt-class","text":"QComboBox","title":"Qt Class"},{"location":"widgets/qsearchablelistwidget/","text":"QSearchableListWidget QSearchableListWidget is a variant of QListWidget that add text entry above list widget that allow to filter list of available options. Due to implementation details, this widget it does not inherit directly from QListWidget but it does fully satisfy its api. The only limitation is that it cannot be used as argument of QListWidgetItem constructor. from qtpy.QtWidgets import QApplication from superqt import QSearchableListWidget app = QApplication ([]) slider = QSearchableListWidget () slider . addItems ([ \"foo\" , \"bar\" , \"baz\" , \"foobar\" , \"foobaz\" , \"barbaz\" ]) slider . show () app . exec_ () Qt Class QWidget Methods addItem ( * args ) addItems ( * args ) insertItem ( * args ) insertItems ( * args ) update_visible ( text )","title":"QSearchableListWidget"},{"location":"widgets/qsearchablelistwidget/#qsearchablelistwidget","text":"QSearchableListWidget is a variant of QListWidget that add text entry above list widget that allow to filter list of available options. Due to implementation details, this widget it does not inherit directly from QListWidget but it does fully satisfy its api. The only limitation is that it cannot be used as argument of QListWidgetItem constructor. from qtpy.QtWidgets import QApplication from superqt import QSearchableListWidget app = QApplication ([]) slider = QSearchableListWidget () slider . addItems ([ \"foo\" , \"bar\" , \"baz\" , \"foobar\" , \"foobaz\" , \"barbaz\" ]) slider . show () app . exec_ ()","title":"QSearchableListWidget"},{"location":"widgets/qsearchablelistwidget/#qt-class","text":"QWidget","title":"Qt Class"},{"location":"widgets/qsearchablelistwidget/#methods","text":"","title":"Methods"},{"location":"widgets/qsearchablelistwidget/#superqt.selection._searchable_list_widget.QSearchableListWidget.addItem","text":"","title":"addItem()"},{"location":"widgets/qsearchablelistwidget/#superqt.selection._searchable_list_widget.QSearchableListWidget.addItems","text":"","title":"addItems()"},{"location":"widgets/qsearchablelistwidget/#superqt.selection._searchable_list_widget.QSearchableListWidget.insertItem","text":"","title":"insertItem()"},{"location":"widgets/qsearchablelistwidget/#superqt.selection._searchable_list_widget.QSearchableListWidget.insertItems","text":"","title":"insertItems()"},{"location":"widgets/qsearchablelistwidget/#superqt.selection._searchable_list_widget.QSearchableListWidget.update_visible","text":"","title":"update_visible()"}]}